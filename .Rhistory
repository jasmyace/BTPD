sum(ugh$sampleID.x - ugh$sampleID.y)
head(shpObj@data)
head(ranks)
hpObj@data <- ranks
shpObj@data <- ranks
head(shpObj@data)
table(shpObj@data$dblSamp)
1136/(1136+9965)
shpDir
help(writeOGR)
shp
writeOGR(shpObj,shpDir,"BTPD_Grid_CO_Ranked",overwrite_layer=TRUE,driver="ESRI Shapefile")
theNext
theFolder <- tblFolders[tblFolders$Grid_ID == theNext,]
theRange <- theFolder$Range
#   ---- Pull Grid_IDs that are to buffer the new Grid_ID.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
shpBuf <- makeBuffer(shpObj,cell=theNext,radius=2.5,cellDim.m=3218.69,inner=TRUE)
shpBuf <- shpBuf[shpBuf@data$Grid_ID != theNext,]
shpGID <- makeBuffer(shpObj,cell=theNext,radius=1.0,cellDim.m=3218.69,inner=TRUE)
shpBuf@data
head(ranks)
ranks <- ranks[order(ranks$sampleID),]
head(ranks)
shpObj@data[shpObj@data$Grid_ID == "CO125913",]
checkBuf <- master[master$Grid_ID %in% shpBuf@data$Grid_ID,]
checkBuf
#   ---- We now need to ensure all cells are available.
Copen <- checkBuf$openStatus    # The cell still needs to be digitized.
Cdigi <- checkBuf$digiStatus    # The cell is locked for digitizing.
Cbuff <- checkBuf$buffStatus    # The cell is locked for buffering.
Cdone <- checkBuf$doneStatus    # The cell has been digitized and reconciled, if necessary.
#   ---- Check.  The cell cannot currently be out for digitizing or buffering.
Cvalid <-  !Cdigi & !Cbuff     # Want:     0  &  0
nCValid <- length(Cvalid[Cvalid == TRUE])
nCValid == nrow(checkBuf)
#   ---- We found a valid cell with a good buffer.
cat("Found a candidate cell...fetching buffering towns and preparing for release.\n")
#   ---- See if it's a double sample cell.
double <- master[master$Grid_ID == theNext,]$dblSamp
double
double <- 0
#   ---- Update the records in data frame assign for the digitizing Grid_ID.
assign[assign$Grid_ID == theNext,]$openStatus <- 0
assign[assign$Grid_ID == theNext,]$digiStatus <- 1
assign[assign$Grid_ID == theNext,]$digiUserID <- userID
assign[assign$Grid_ID == theNext,]$digiSingle <- 1
assign[assign$Grid_ID == theNext,]$digiDouble <- 0
partner <- 998
assign[assign$Grid_ID == theNext,]$digiPartner <- partner
#   ---- Update the time records.  At the least, we don't want endTimes that are before startTimes.
assign[assign$Grid_ID == theNext,]$digiStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == theNext,]$digiEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
j
j <- 1
shpBuf@data
bufGrid_ID <- as.character(droplevels(shpBuf@data[j,]$Grid_ID))
assign[assign$Grid_ID == bufGrid_ID,]$buffStatus <- 1
assign[assign$Grid_ID == bufGrid_ID,]$buffLockGrid_ID <- theNext
assign[assign$Grid_ID == bufGrid_ID,]$buffUserID <- userID
assign[assign$Grid_ID == bufGrid_ID,]$buffPartner <- partner
assign[assign$Grid_ID == bufGrid_ID,]$buffStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == bufGrid_ID,]$buffEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
#   ---- Compile all town shapefiles from neighbors of the locking Grid_ID
#   ---- and place in the folder so digitizer knows they are there.
townShps <- vector("list",nrow(shpBuf@data))
bufFolders <- tblFolders[tblFolders$Grid_ID %in% shpBuf@data$Grid_ID,]
bufRange <- bufFolders[bufFolders$Grid_ID == bufGrid_ID,]$Range
bufFolder <- paste0("//lar-file-srv/Data/BTPD_2016/Digitizing/",bufRange,"/",bufGrid_ID,"/")
bufDone <- assign[assign$Grid_ID == bufGrid_ID,]$doneStatus
#   ---- Find out if the neighboring buffefing cell was singly or
#   ---- doubly digitized.  This tells us which shapefile actually
#   ---- holds the towns we care about.
bufBASN <- master[master$Grid_ID == bufGrid_ID,]$sampleID
bufDoub <- master[master$Grid_ID == bufGrid_ID,]$dblSamp
#   ---- Get any valid town shapefiles and place in a list.
#   ---- Note we only get those with a higher BAS Number.
#   ---- This *could* create a conflict if a higher-BAS-
#   ---- Number town has been drawn that overlaps with the
#   ---- current town of interest.  But the current cell
#   ---- gets first dibs.
bufDone
if(bufDone == 1){
bufUserID <- master[master$Grid_ID == bufGrid_ID,]$digiUserID
FirstName <- tblNames[tblNames$bufUserID == bufUserID,]
if(bufDoub == 0){
if( file.exists(paste0(bufFolder,"p",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(paste0(shpsDir,"BTPD_Grid_CO_Ranked"),paste0("Epsilon-",bufGrid_ID))
}
} else {
if( file.exists(paste0(bufFolder,"p",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(paste0(shpsDir,"BTPD_Grid_CO_Ranked"),paste0("Epsilon-",bufGrid_ID))
}
}
}
j <- 2
bufGrid_ID <- as.character(droplevels(shpBuf@data[j,]$Grid_ID))
assign[assign$Grid_ID == bufGrid_ID,]$buffStatus <- 1
assign[assign$Grid_ID == bufGrid_ID,]$buffLockGrid_ID <- theNext
assign[assign$Grid_ID == bufGrid_ID,]$buffUserID <- userID
assign[assign$Grid_ID == bufGrid_ID,]$buffPartner <- partner
assign[assign$Grid_ID == bufGrid_ID,]$buffStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == bufGrid_ID,]$buffEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
#   ---- Compile all town shapefiles from neighbors of the locking Grid_ID
#   ---- and place in the folder so digitizer knows they are there.
townShps <- vector("list",nrow(shpBuf@data))
bufFolders <- tblFolders[tblFolders$Grid_ID %in% shpBuf@data$Grid_ID,]
bufRange <- bufFolders[bufFolders$Grid_ID == bufGrid_ID,]$Range
bufFolder <- paste0("//lar-file-srv/Data/BTPD_2016/Digitizing/",bufRange,"/",bufGrid_ID,"/")
bufDone <- assign[assign$Grid_ID == bufGrid_ID,]$doneStatus
#   ---- Find out if the neighboring buffefing cell was singly or
#   ---- doubly digitized.  This tells us which shapefile actually
#   ---- holds the towns we care about.
bufBASN <- master[master$Grid_ID == bufGrid_ID,]$sampleID
bufDoub <- master[master$Grid_ID == bufGrid_ID,]$dblSamp
#   ---- Get any valid town shapefiles and place in a list.
#   ---- Note we only get those with a higher BAS Number.
#   ---- This *could* create a conflict if a higher-BAS-
#   ---- Number town has been drawn that overlaps with the
#   ---- current town of interest.  But the current cell
#   ---- gets first dibs.
bufDone
bufGrid_ID
theNext
theNext <- "CO124777"
theFolder <- tblFolders[tblFolders$Grid_ID == theNext,]
theRange <- theFolder$Range
#   ---- Pull Grid_IDs that are to buffer the new Grid_ID.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
shpBuf <- makeBuffer(shpObj,cell=theNext,radius=2.5,cellDim.m=3218.69,inner=TRUE)
shpBuf <- shpBuf[shpBuf@data$Grid_ID != theNext,]
shpGID <- makeBuffer(shpObj,cell=theNext,radius=1.0,cellDim.m=3218.69,inner=TRUE)
#   ---- Make sure we have no Out-for-Digitizing Grid_IDs in the selected
#   ---- Grid_ID's buffer.  Note that buff indicator used above is the set
#   ---- of buffering cells UP to this possibly new cell.
checkBuf <- master[master$Grid_ID %in% shpBuf@data$Grid_ID,]
#   ---- We now need to ensure all cells are available.
Copen <- checkBuf$openStatus    # The cell still needs to be digitized.
Cdigi <- checkBuf$digiStatus    # The cell is locked for digitizing.
Cbuff <- checkBuf$buffStatus    # The cell is locked for buffering.
Cdone <- checkBuf$doneStatus    # The cell has been digitized and reconciled, if necessary.
#   ---- Check.  The cell cannot currently be out for digitizing or buffering.
Cvalid <-  !Cdigi & !Cbuff     # Want:     0  &  0
nCValid <- length(Cvalid[Cvalid == TRUE])
nCValid == nrow(checkBuf)
#   ---- We found a valid cell with a good buffer.
cat("Found a candidate cell...fetching buffering towns and preparing for release.\n")
#   ---- See if it's a double sample cell.
double <- master[master$Grid_ID == theNext,]$dblSamp
#   ---- Update the records in data frame assign for the digitizing Grid_ID.
assign[assign$Grid_ID == theNext,]$openStatus <- 0
assign[assign$Grid_ID == theNext,]$digiStatus <- 1
assign[assign$Grid_ID == theNext,]$digiUserID <- userID
assign[assign$Grid_ID == theNext,]$digiSingle <- 1
assign[assign$Grid_ID == theNext,]$digiDouble <- 0
partner <- 998
assign[assign$Grid_ID == theNext,]$digiPartner <- partner
#   ---- Update the time records.  At the least, we don't want endTimes that are before startTimes.
assign[assign$Grid_ID == theNext,]$digiStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == theNext,]$digiEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
j <- 1
shpBuf@data
theNext
theNext <- "CO124418"
theFolder <- tblFolders[tblFolders$Grid_ID == theNext,]
theRange <- theFolder$Range
#   ---- Pull Grid_IDs that are to buffer the new Grid_ID.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
shpBuf <- makeBuffer(shpObj,cell=theNext,radius=2.5,cellDim.m=3218.69,inner=TRUE)
shpBuf <- shpBuf[shpBuf@data$Grid_ID != theNext,]
shpGID <- makeBuffer(shpObj,cell=theNext,radius=1.0,cellDim.m=3218.69,inner=TRUE)
#   ---- Make sure we have no Out-for-Digitizing Grid_IDs in the selected
#   ---- Grid_ID's buffer.  Note that buff indicator used above is the set
#   ---- of buffering cells UP to this possibly new cell.
checkBuf <- master[master$Grid_ID %in% shpBuf@data$Grid_ID,]
#   ---- We now need to ensure all cells are available.
Copen <- checkBuf$openStatus    # The cell still needs to be digitized.
Cdigi <- checkBuf$digiStatus    # The cell is locked for digitizing.
Cbuff <- checkBuf$buffStatus    # The cell is locked for buffering.
Cdone <- checkBuf$doneStatus    # The cell has been digitized and reconciled, if necessary.
#   ---- Check.  The cell cannot currently be out for digitizing or buffering.
Cvalid <-  !Cdigi & !Cbuff     # Want:     0  &  0
nCValid <- length(Cvalid[Cvalid == TRUE])
nCValid == nrow(checkBuf)
#   ---- We found a valid cell with a good buffer.
cat("Found a candidate cell...fetching buffering towns and preparing for release.\n")
#   ---- Update the records in data frame assign for the digitizing Grid_ID.
assign[assign$Grid_ID == theNext,]$openStatus <- 0
assign[assign$Grid_ID == theNext,]$digiStatus <- 1
assign[assign$Grid_ID == theNext,]$digiUserID <- userID
assign[assign$Grid_ID == theNext,]$digiSingle <- 1
assign[assign$Grid_ID == theNext,]$digiDouble <- 0
double
double <- 0
partner <- 998
assign[assign$Grid_ID == theNext,]$digiPartner <- partner
#   ---- Update the time records.  At the least, we don't want endTimes that are before startTimes.
assign[assign$Grid_ID == theNext,]$digiStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == theNext,]$digiEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
j
shpBuf@data
for( j in 1:nrow(shpBuf@data) ){
bufGrid_ID <- as.character(droplevels(shpBuf@data[j,]$Grid_ID))
assign[assign$Grid_ID == bufGrid_ID,]$buffStatus <- 1
assign[assign$Grid_ID == bufGrid_ID,]$buffLockGrid_ID <- theNext
assign[assign$Grid_ID == bufGrid_ID,]$buffUserID <- userID
assign[assign$Grid_ID == bufGrid_ID,]$buffPartner <- partner
assign[assign$Grid_ID == bufGrid_ID,]$buffStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == bufGrid_ID,]$buffEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
#   ---- Compile all town shapefiles from neighbors of the locking Grid_ID
#   ---- and place in the folder so digitizer knows they are there.
townShps <- vector("list",nrow(shpBuf@data))
bufFolders <- tblFolders[tblFolders$Grid_ID %in% shpBuf@data$Grid_ID,]
bufRange <- bufFolders[bufFolders$Grid_ID == bufGrid_ID,]$Range
bufFolder <- paste0("//lar-file-srv/Data/BTPD_2016/Digitizing/",bufRange,"/",bufGrid_ID,"/")
bufDone <- assign[assign$Grid_ID == bufGrid_ID,]$doneStatus
#   ---- Find out if the neighboring buffefing cell was singly or
#   ---- doubly digitized.  This tells us which shapefile actually
#   ---- holds the towns we care about.
bufBASN <- master[master$Grid_ID == bufGrid_ID,]$sampleID
bufDoub <- master[master$Grid_ID == bufGrid_ID,]$dblSamp
#   ---- Get any valid town shapefiles and place in a list.
#   ---- Note we only get those with a higher BAS Number.
#   ---- This *could* create a conflict if a higher-BAS-
#   ---- Number town has been drawn that overlaps with the
#   ---- current town of interest.  But the current cell
#   ---- gets first dibs.
if(bufDone == 1){
bufUserID <- master[master$Grid_ID == bufGrid_ID,]$digiUserID
FirstName <- tblNames[tblNames$bufUserID == bufUserID,]
if(bufDoub == 0){
if( file.exists(paste0(bufFolder,"p",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(paste0(shpsDir,"BTPD_Grid_CO_Ranked"),paste0("Epsilon-",bufGrid_ID))
}
} else {
if( file.exists(paste0(bufFolder,"p",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(paste0(shpsDir,"BTPD_Grid_CO_Ranked"),paste0("Epsilon-",bufGrid_ID))
}
}
}
}
j
master[master$Grid_ID == bufGrid_ID,]
bufGrid_ID
bufBASN <- assign[assign$Grid_ID == bufGrid_ID,]$sampleID
bufDoub <- assign[assign$Grid_ID == bufGrid_ID,]$dblSamp
bufDoub
bufDoub <- ranks[ranks$Grid_ID == bufGrid_ID,]$dblSamp
bufDoub
bufDone
bufUserID <- master[master$Grid_ID == bufGrid_ID,]$digiUserID
FirstName <- tblNames[tblNames$bufUserID == bufUserID,]
FirstName
bufUserID
bufUserID <- assign[assign$Grid_ID == bufGrid_ID,]$digiUserID
FirstName <- tblNames[tblNames$bufUserID == bufUserID,]
FirstName
bufUserID
tblNames[tblNames$UserID == bufUserID,]
tblNames
FirstName <- tblNames[tblNames$userID == bufUserID,]
FirstName
bufDoub == 0
paste0(bufFolder,"p",FirstName,"_",bufGrid_ID,".shp")
FirstName
FirstName <- tblNames[tblNames$userID == bufUserID,]$FirstName
bufGrid_ID
paste0(bufFolder,"p",FirstName,"_Towns_",bufGrid_ID,".shp")
file.exists(paste0(bufFolder,"p",FirstName,"_Towns_",bufGrid_ID,".shp"))
bufBASN
bufBASN <- ranks[ranks$Grid_ID == bufGrid_ID,]$sampleID
bufBASN
bufBASN
theBASN
master[master$Grid_ID == theNext,]$sampleID
theBASN <- 4956
file.exists(paste0(bufFolder,"p",FirstName,"_Towns_",bufGrid_ID,".shp")) & (bufBASN < theBASN)
bufFolder
substr(bufFolder,1,nchar(bufFolder) - 1)
paste0("p",FirstName,"_Towns_",bufGrid_ID)
j
townShps[[j]] <- readOGR(substr(bufFolder,1,nchar(bufFolder) - 1),paste0("p",FirstName,"_Towns_",bufGrid_ID))
townShps[[j]] <- readOGR(substr(bufFolder,1,nchar(bufFolder) - 1),paste0("p",FirstName,"_Towns_",bufGrid_ID),verbose=FALSE)
plot(townShps[[j]])
paste0("reconciling_Towns_",bufGrid_ID)
for( j in 1:nrow(shpBuf@data) ){
bufGrid_ID <- as.character(droplevels(shpBuf@data[j,]$Grid_ID))
assign[assign$Grid_ID == bufGrid_ID,]$buffStatus <- 1
assign[assign$Grid_ID == bufGrid_ID,]$buffLockGrid_ID <- theNext
assign[assign$Grid_ID == bufGrid_ID,]$buffUserID <- userID
assign[assign$Grid_ID == bufGrid_ID,]$buffPartner <- partner
assign[assign$Grid_ID == bufGrid_ID,]$buffStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == bufGrid_ID,]$buffEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
#   ---- Compile all town shapefiles from neighbors of the locking Grid_ID
#   ---- and place in the folder so digitizer knows they are there.
townShps <- vector("list",nrow(shpBuf@data))
bufFolders <- tblFolders[tblFolders$Grid_ID %in% shpBuf@data$Grid_ID,]
bufRange <- bufFolders[bufFolders$Grid_ID == bufGrid_ID,]$Range
bufFolder <- paste0("//lar-file-srv/Data/BTPD_2016/Digitizing/",bufRange,"/",bufGrid_ID,"/")
bufDone <- assign[assign$Grid_ID == bufGrid_ID,]$doneStatus
#   ---- Find out if the neighboring buffefing cell was singly or
#   ---- doubly digitized.  This tells us which shapefile actually
#   ---- holds the towns we care about.
bufBASN <- ranks[ranks$Grid_ID == bufGrid_ID,]$sampleID
bufDoub <- ranks[ranks$Grid_ID == bufGrid_ID,]$dblSamp
#   ---- Get any valid town shapefiles and place in a list.
#   ---- Note we only get those with a higher BAS Number.
#   ---- This *could* create a conflict if a higher-BAS-
#   ---- Number town has been drawn that overlaps with the
#   ---- current town of interest.  But the current cell
#   ---- gets first dibs.
if(bufDone == 1){
bufUserID <- assign[assign$Grid_ID == bufGrid_ID,]$digiUserID
FirstName <- tblNames[tblNames$userID == bufUserID,]$FirstName
if(bufDoub == 0){
if( file.exists(paste0(bufFolder,"p",FirstName,"_Towns_",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(substr(bufFolder,1,nchar(bufFolder) - 1),paste0("p",FirstName,"_Towns_",bufGrid_ID),verbose=FALSE)
}
} else {
if( file.exists(paste0(bufFolder,"reconciling_Towns_",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(substr(bufFolder,1,nchar(bufFolder) - 1),paste0("reconciling_Towns_",bufGrid_ID),verbose=FALSE)
}
}
}
}
allShps <- NULL
for(j in 1:length(townShps)){
if(!is.null(townShps[[j]])){
nR <- length(slot(townShps[[j]],"polygons"));
if(j == 1){                                                                                                                                                                               # for 1st shp file, do this
uidR          <- 1;                                                                                                                                                               # make a unique id
allShps       <- spChFIDs(townShps[[j]], as.character(uidR:(uidR + nR - 1)));                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR;
} else {                                                                                                                                                                                  # for other than 1st shp file, do this
townShps[[j]] <- spChFIDs(townShps[[j]], as.character(uidR:(uidR + nR - 1)));                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR;                                                                                                                                                       # make unique id for all polys
allShps       <- spRbind(allShps,townShps[[j]]);                                                                                                                                   # union ith shp file with all previous ones
}
}
}
dev.off()
plot(allShps)
townShps[[7]]
shpBuf@data
for( j in 1:nrow(shpBuf@data) ){
bufGrid_ID <- as.character(droplevels(shpBuf@data[j,]$Grid_ID))
assign[assign$Grid_ID == bufGrid_ID,]$buffStatus <- 1
assign[assign$Grid_ID == bufGrid_ID,]$buffLockGrid_ID <- theNext
assign[assign$Grid_ID == bufGrid_ID,]$buffUserID <- userID
assign[assign$Grid_ID == bufGrid_ID,]$buffPartner <- partner
assign[assign$Grid_ID == bufGrid_ID,]$buffStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == bufGrid_ID,]$buffEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
#   ---- Compile all town shapefiles from neighbors of the locking Grid_ID
#   ---- and place in the folder so digitizer knows they are there.
townShps <- vector("list",nrow(shpBuf@data))
bufFolders <- tblFolders[tblFolders$Grid_ID %in% shpBuf@data$Grid_ID,]
bufRange <- bufFolders[bufFolders$Grid_ID == bufGrid_ID,]$Range
bufFolder <- paste0("//lar-file-srv/Data/BTPD_2016/Digitizing/",bufRange,"/",bufGrid_ID,"/")
bufDone <- assign[assign$Grid_ID == bufGrid_ID,]$doneStatus
#   ---- Find out if the neighboring buffefing cell was singly or
#   ---- doubly digitized.  This tells us which shapefile actually
#   ---- holds the towns we care about.
bufBASN <- ranks[ranks$Grid_ID == bufGrid_ID,]$sampleID
bufDoub <- ranks[ranks$Grid_ID == bufGrid_ID,]$dblSamp
#   ---- Get any valid town shapefiles and place in a list.
#   ---- Note we only get those with a higher BAS Number.
#   ---- This *could* create a conflict if a higher-BAS-
#   ---- Number town has been drawn that overlaps with the
#   ---- current town of interest.  But the current cell
#   ---- gets first dibs.
if(bufDone == 1){
bufUserID <- assign[assign$Grid_ID == bufGrid_ID,]$digiUserID
FirstName <- tblNames[tblNames$userID == bufUserID,]$FirstName
if(bufDoub == 0){
if( file.exists(paste0(bufFolder,"p",FirstName,"_Towns_",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(substr(bufFolder,1,nchar(bufFolder) - 1),paste0("p",FirstName,"_Towns_",bufGrid_ID),verbose=FALSE)
}
} else {
if( file.exists(paste0(bufFolder,"reconciling_Towns_",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(substr(bufFolder,1,nchar(bufFolder) - 1),paste0("reconciling_Towns_",bufGrid_ID),verbose=FALSE)
}
}
}
}
plot(townShps[[7]])
j <- 7
bufGrid_ID <- as.character(droplevels(shpBuf@data[j,]$Grid_ID))
assign[assign$Grid_ID == bufGrid_ID,]$buffStatus <- 1
assign[assign$Grid_ID == bufGrid_ID,]$buffLockGrid_ID <- theNext
assign[assign$Grid_ID == bufGrid_ID,]$buffUserID <- userID
assign[assign$Grid_ID == bufGrid_ID,]$buffPartner <- partner
assign[assign$Grid_ID == bufGrid_ID,]$buffStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == bufGrid_ID,]$buffEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
#   ---- Compile all town shapefiles from neighbors of the locking Grid_ID
#   ---- and place in the folder so digitizer knows they are there.
townShps <- vector("list",nrow(shpBuf@data))
bufFolders <- tblFolders[tblFolders$Grid_ID %in% shpBuf@data$Grid_ID,]
bufRange <- bufFolders[bufFolders$Grid_ID == bufGrid_ID,]$Range
bufFolder <- paste0("//lar-file-srv/Data/BTPD_2016/Digitizing/",bufRange,"/",bufGrid_ID,"/")
bufDone <- assign[assign$Grid_ID == bufGrid_ID,]$doneStatus
#   ---- Find out if the neighboring buffefing cell was singly or
#   ---- doubly digitized.  This tells us which shapefile actually
#   ---- holds the towns we care about.
bufBASN <- ranks[ranks$Grid_ID == bufGrid_ID,]$sampleID
bufDoub <- ranks[ranks$Grid_ID == bufGrid_ID,]$dblSamp
#   ---- Get any valid town shapefiles and place in a list.
#   ---- Note we only get those with a higher BAS Number.
#   ---- This *could* create a conflict if a higher-BAS-
#   ---- Number town has been drawn that overlaps with the
#   ---- current town of interest.  But the current cell
#   ---- gets first dibs.
bufBASN
bufDoub
bufDone
bufDone == 1
bufUserID <- assign[assign$Grid_ID == bufGrid_ID,]$digiUserID
FirstName <- tblNames[tblNames$userID == bufUserID,]$FirstName
FirstName
bufDoub == 0
file.exists(paste0(bufFolder,"p",FirstName,"_Towns_",bufGrid_ID,".shp")) & (bufBASN < theBASN)
townShps[[j]] <- readOGR(substr(bufFolder,1,nchar(bufFolder) - 1),paste0("p",FirstName,"_Towns_",bufGrid_ID),verbose=FALSE)
plot(townShps[[j]])
#   ---- Update the data frame assign with the cells that are buffering,
#   ---- and ID the Grid_ID causing the lock.
townShps <- vector("list",nrow(shpBuf@data))
for( j in 1:nrow(shpBuf@data) ){
bufGrid_ID <- as.character(droplevels(shpBuf@data[j,]$Grid_ID))
assign[assign$Grid_ID == bufGrid_ID,]$buffStatus <- 1
assign[assign$Grid_ID == bufGrid_ID,]$buffLockGrid_ID <- theNext
assign[assign$Grid_ID == bufGrid_ID,]$buffUserID <- userID
assign[assign$Grid_ID == bufGrid_ID,]$buffPartner <- partner
assign[assign$Grid_ID == bufGrid_ID,]$buffStartTime <- as.POSIXct(Sys.time(),tz="America/Denver")
assign[assign$Grid_ID == bufGrid_ID,]$buffEndTime <- as.POSIXct(Sys.time(),tz="America/Denver")
#   ---- Compile all town shapefiles from neighbors of the locking Grid_ID
#   ---- and place in the folder so digitizer knows they are there.
bufFolders <- tblFolders[tblFolders$Grid_ID %in% shpBuf@data$Grid_ID,]
bufRange <- bufFolders[bufFolders$Grid_ID == bufGrid_ID,]$Range
bufFolder <- paste0("//lar-file-srv/Data/BTPD_2016/Digitizing/",bufRange,"/",bufGrid_ID,"/")
bufDone <- assign[assign$Grid_ID == bufGrid_ID,]$doneStatus
#   ---- Find out if the neighboring buffefing cell was singly or
#   ---- doubly digitized.  This tells us which shapefile actually
#   ---- holds the towns we care about.
bufBASN <- ranks[ranks$Grid_ID == bufGrid_ID,]$sampleID
bufDoub <- ranks[ranks$Grid_ID == bufGrid_ID,]$dblSamp
#   ---- Get any valid town shapefiles and place in a list.
#   ---- Note we only get those with a higher BAS Number.
#   ---- This *could* create a conflict if a higher-BAS-
#   ---- Number town has been drawn that overlaps with the
#   ---- current town of interest.  But the current cell
#   ---- gets first dibs.
if(bufDone == 1){
bufUserID <- assign[assign$Grid_ID == bufGrid_ID,]$digiUserID
FirstName <- tblNames[tblNames$userID == bufUserID,]$FirstName
if(bufDoub == 0){
if( file.exists(paste0(bufFolder,"p",FirstName,"_Towns_",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(substr(bufFolder,1,nchar(bufFolder) - 1),paste0("p",FirstName,"_Towns_",bufGrid_ID),verbose=FALSE)
}
} else {
if( file.exists(paste0(bufFolder,"reconciling_Towns_",bufGrid_ID,".shp")) & (bufBASN < theBASN) ){
townShps[[j]] <- readOGR(substr(bufFolder,1,nchar(bufFolder) - 1),paste0("reconciling_Towns_",bufGrid_ID),verbose=FALSE)
}
}
}
}
plot(townShps[[7]])
#   ---- Given the list of neighboring towns, paste together
#   ---- into one nice shapefile.
allShps <- NULL
for(j in 1:length(townShps)){
if(!is.null(townShps[[j]])){
nR <- length(slot(townShps[[j]],"polygons"));
if(j == 1){                                                                                                                                                                               # for 1st shp file, do this
uidR          <- 1;                                                                                                                                                               # make a unique id
allShps       <- spChFIDs(townShps[[j]], as.character(uidR:(uidR + nR - 1)));                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR;
} else {                                                                                                                                                                                  # for other than 1st shp file, do this
townShps[[j]] <- spChFIDs(townShps[[j]], as.character(uidR:(uidR + nR - 1)));                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR;                                                                                                                                                       # make unique id for all polys
allShps       <- spRbind(allShps,townShps[[j]]);                                                                                                                                   # union ith shp file with all previous ones
}
}
}
#   ---- Given the list of neighboring towns, paste together
#   ---- into one nice shapefile.
allShps <- NULL
first <- 0
triggered <- 0
for(j in 1:length(townShps)){
if(!is.null(townShps[[j]])){
nR <- length(slot(townShps[[j]],"polygons"))
if(triggered == 0){
first <- 1
}
if(first == 1){                                                                                                                                                                                  # for 1st shp file, do this
uidR          <- 1                                                                                                                                                               # make a unique id
allShps       <- spChFIDs(townShps[[j]], as.character(uidR:(uidR + nR - 1)))                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR
triggered     <- 1
first         <- 0
} else {                                                                                                                                                                                  # for other than 1st shp file, do this
townShps[[j]] <- spChFIDs(townShps[[j]], as.character(uidR:(uidR + nR - 1)))                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR                                                                                                                                              # make unique id for all polys
allShps       <- spRbind(allShps,townShps[[j]])                                                                                                                                  # union ith shp file with all previous ones
}
}
}
dev.off()
plot(allShps)
otherTowns <- 0
!is.null(allShps)
paste0("//lar-file-srv/Data/BTPD_2016/Digitizing/",theFolder$Range,"/",theNext)
paste0("LocalTowns_",theNext)
