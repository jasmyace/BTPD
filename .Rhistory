#   ---- Get the current list of who has what.
assign <- getCellStatus()
assign$digiStartTime <- as.POSIXlt(assign$digiStartTime,tz="America/Denver")
assign$digiEndTime <- as.POSIXlt(assign$digiEndTime,tz="America/Denver")
assign$buffStartTime <- as.POSIXlt(assign$buffStartTime,tz="America/Denver")
assign$buffEndTime <- as.POSIXlt(assign$buffEndTime,tz="America/Denver")
anyOpen <- assign[assign$digiStatus == 1 & assign$digiUser == userID & assign$digiPartner == 998,]
user<-100
#   ---- Define useful projections.
projAEAc  <- '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0'
#   ---- Check to make sure user is legitimate.
tblNames <- checkUser(userID)
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == userID,]$FirstName))
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
assign$digiStartTime <- as.POSIXlt(assign$digiStartTime,tz="America/Denver")
assign$digiEndTime <- as.POSIXlt(assign$digiEndTime,tz="America/Denver")
assign$buffStartTime <- as.POSIXlt(assign$buffStartTime,tz="America/Denver")
assign$buffEndTime <- as.POSIXlt(assign$buffEndTime,tz="America/Denver")
anyOpen <- assign[assign$digiStatus == 1 & assign$digiUser == userID & assign$digiPartner == 998,]
checkUser <- function(userID,tblDir="//lar-file-srv/Data/BTPD_2016/Analysis/Database/"){
# userID <- 102
# tblDir <- "//lar-file-srv/Data/BTPD_2016/Analysis/Database/"
#   ---- Find the user.
tblNames <- read.csv(paste0(tblDir,"tblNames.csv"))
tblNamesUserID <- tblNames[tblNames$userID == userID,]
#   ---- Check user status and active status.
if( nrow(tblNamesUserID) == 0 ){
stop("The userID submitted was not found.  Try again.",call.=FALSE)
} else if( nrow(tblNamesUserID) == 1 & tblNamesUserID$singleActive == 0 ){
stop("The userID submitted was found but is inactive.  Try again.",call.=FALSE)
}
tblNames
}
tblNames <- checkUser(userID)
userID <- 100
tblNames <- checkUser(userID)
#   ---- Define useful projections.
projAEAc  <- '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0'
#   ---- Check to make sure user is legitimate.
tblNames <- checkUser(userID)
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == userID,]$FirstName))
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
assign$digiStartTime <- as.POSIXlt(assign$digiStartTime,tz="America/Denver")
assign$digiEndTime <- as.POSIXlt(assign$digiEndTime,tz="America/Denver")
assign$buffStartTime <- as.POSIXlt(assign$buffStartTime,tz="America/Denver")
assign$buffEndTime <- as.POSIXlt(assign$buffEndTime,tz="America/Denver")
#   ---- Get the BAS rankings.
ranks <- getRankStatus()
#   ---- Make a master data frame.
master <- merge(assign,ranks,by=c("Grid_ID"),all.x=TRUE,all.y=TRUE)
master <- master[order(master$digiStatus,master$sampleID),]
nTotal <- nrow(master)
#   ---- We now need to find a cell whose buffer is available.
open <- master$openStatus    # The cell still needs to be digitizing.
digi <- master$digiStatus    # The cell is locked for digitizing.
buff <- master$buffStatus    # The cell is locked for buffering.
done <- master$doneStatus    # The cell has been digitized and reconciled, if necessary.
#   ---- Could have a few open cells, but they're locked for digitizing or buffering.
valid <- open & !digi & !buff & !done    # Want:    1  &  0  &  0  &  0
nValid <- length(valid[valid == TRUE])
#   ---- Reduce our options to only the list that we know is available.
master <- master[valid,]
#   ---- Assign an index that is the absolute position (in rows) in master.
i <- 1
found <- FALSE
theNext
theFolder <- tblFolders[tblFolders$Grid_ID == theNext,]
theRange <- theFolder$Range
#   ---- Pull Grid_IDs that are to buffer the new Grid_ID.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
shpBuf <- makeBuffer(shpObj,cell=theNext,radius=2.5,cellDim.m=3218.69,inner=TRUE)
shpBuf <- shpBuf[shpBuf@data$Grid_ID != theNext,]
shpGID <- makeBuffer(shpObj,cell=theNext,radius=1.0,cellDim.m=3218.69,inner=TRUE)
#   ---- Make sure we have no Out-for-Digitizing Grid_IDs in the selected
#   ---- Grid_ID's buffer.  Note that buff indicator used above is the set
#   ---- of buffering cells UP to this possibly new cell.
checkBuf <- master[master$Grid_ID %in% shpBuf@data$Grid_ID,]
#   ---- We now need to ensure all cells are available.
Copen <- checkBuf$openStatus    # The cell still needs to be digitized.
Cdigi <- checkBuf$digiStatus    # The cell is locked for digitizing.
Cbuff <- checkBuf$buffStatus    # The cell is locked for buffering.
Cdone <- checkBuf$doneStatus    # The cell has been digitized and reconciled, if necessary.
#   ---- Check.  The cell cannot currently be out for digitizing or buffering.
Cvalid <-  !Cdigi & !Cbuff     # Want:     0  &  0
nCValid <- length(Cvalid[Cvalid == TRUE])
require(rgdal)
theFolder <- tblFolders[tblFolders$Grid_ID == theNext,]
theRange <- theFolder$Range
#   ---- Pull Grid_IDs that are to buffer the new Grid_ID.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
shpBuf <- makeBuffer(shpObj,cell=theNext,radius=2.5,cellDim.m=3218.69,inner=TRUE)
shpBuf <- shpBuf[shpBuf@data$Grid_ID != theNext,]
shpGID <- makeBuffer(shpObj,cell=theNext,radius=1.0,cellDim.m=3218.69,inner=TRUE)
#   ---- Make sure we have no Out-for-Digitizing Grid_IDs in the selected
#   ---- Grid_ID's buffer.  Note that buff indicator used above is the set
#   ---- of buffering cells UP to this possibly new cell.
checkBuf <- master[master$Grid_ID %in% shpBuf@data$Grid_ID,]
#   ---- We now need to ensure all cells are available.
Copen <- checkBuf$openStatus    # The cell still needs to be digitized.
Cdigi <- checkBuf$digiStatus    # The cell is locked for digitizing.
Cbuff <- checkBuf$buffStatus    # The cell is locked for buffering.
Cdone <- checkBuf$doneStatus    # The cell has been digitized and reconciled, if necessary.
#   ---- Check.  The cell cannot currently be out for digitizing or buffering.
Cvalid <-  !Cdigi & !Cbuff     # Want:     0  &  0
nCValid <- length(Cvalid[Cvalid == TRUE])
#' @export makeBuffer
#'
#' @author Jason Mitchell (jmitchell@@west-inc.com)
#'
#' @seealso \code{\link{gBuffer}}, \code{\link{gIntersects}},
#'   \code{\link{gIntersection}}
makeBuffer <- function(shp,cell,radius=2.5,cellDim.m=3218.69,inner=TRUE){
# shp <- allShps[[2]]
# cell <- "CO132952"
# radius <- 2.5
# cellDim.m <- 3218.69
# inner <- TRUE
#   ---- Make sure the rownames of attribute data in shp match the polygonal IDs.
rownames(shp@data) <- sapply(shp@polygons,function(x) slot(x,"ID"))
#   ---- Make the buffering circle.
center <- gCentroid(shp[shp@data$Grid_ID == cell,])
circle <- gBuffer(center,byid=TRUE,width=radius*cellDim.m)
#   ---- Identify set of possible outer safety cells.
safetyOuterVec <- rownames(gIntersects(circle,shp,byid=TRUE))[gIntersects(circle,shp,byid=TRUE) == TRUE]
#   ---- Restrict the outer safety cells to their own object.
safetyOuter <- shp[rownames(shp@data) %in% safetyOuterVec,]
#   ---- Identify the inner safety cells with cells entirely in circle.
#   ---- Do this by seeing that 4 square miles = 10359994 square meters.
preSafetyInnerVec <- gArea(gIntersection(circle,safetyOuter,byid=TRUE),byid=TRUE) >= 10359993
safetyInnerVec <- unlist(strsplit(names(preSafetyInnerVec[preSafetyInnerVec == TRUE])," ",fixed=TRUE))[c(FALSE,TRUE)]
#   ---- Restrict the inner safety cells to their own object.
safetyInner <- shp[rownames(shp@data) %in% safetyInnerVec,]
if( inner == TRUE){
ans <- safetyInner
} else {
ans <- safetyOuter
}
ans
#   plot(shp)
#   plot(shp[shp@data$dblSamp == 1,],add=TRUE,col='red')
#   plot(circle,col="blue")
#   plot(safetyOuter,add=TRUE,col="green")
#   plot(safetyInner,add=TRUE,col="brown")
}
theFolder <- tblFolders[tblFolders$Grid_ID == theNext,]
theRange <- theFolder$Range
#   ---- Pull Grid_IDs that are to buffer the new Grid_ID.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
shpBuf <- makeBuffer(shpObj,cell=theNext,radius=2.5,cellDim.m=3218.69,inner=TRUE)
shpBuf <- shpBuf[shpBuf@data$Grid_ID != theNext,]
shpGID <- makeBuffer(shpObj,cell=theNext,radius=1.0,cellDim.m=3218.69,inner=TRUE)
#   ---- Make sure we have no Out-for-Digitizing Grid_IDs in the selected
#   ---- Grid_ID's buffer.  Note that buff indicator used above is the set
#   ---- of buffering cells UP to this possibly new cell.
checkBuf <- master[master$Grid_ID %in% shpBuf@data$Grid_ID,]
#   ---- We now need to ensure all cells are available.
Copen <- checkBuf$openStatus    # The cell still needs to be digitized.
Cdigi <- checkBuf$digiStatus    # The cell is locked for digitizing.
Cbuff <- checkBuf$buffStatus    # The cell is locked for buffering.
Cdone <- checkBuf$doneStatus    # The cell has been digitized and reconciled, if necessary.
#   ---- Check.  The cell cannot currently be out for digitizing or buffering.
Cvalid <-  !Cdigi & !Cbuff     # Want:     0  &  0
nCValid <- length(Cvalid[Cvalid == TRUE])
tblDir="//lar-file-srv/Data/BTPD_2016/Digitizing"
shpDir="//lar-file-srv/Data/BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_CO_Ranked"
shp="BTPD_Grid_CO_Ranked"
theFolder <- tblFolders[tblFolders$Grid_ID == theNext,]
theRange <- theFolder$Range
#   ---- Pull Grid_IDs that are to buffer the new Grid_ID.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
shpBuf <- makeBuffer(shpObj,cell=theNext,radius=2.5,cellDim.m=3218.69,inner=TRUE)
shpBuf <- shpBuf[shpBuf@data$Grid_ID != theNext,]
shpGID <- makeBuffer(shpObj,cell=theNext,radius=1.0,cellDim.m=3218.69,inner=TRUE)
#   ---- Make sure we have no Out-for-Digitizing Grid_IDs in the selected
#   ---- Grid_ID's buffer.  Note that buff indicator used above is the set
#   ---- of buffering cells UP to this possibly new cell.
checkBuf <- master[master$Grid_ID %in% shpBuf@data$Grid_ID,]
#   ---- We now need to ensure all cells are available.
Copen <- checkBuf$openStatus    # The cell still needs to be digitized.
Cdigi <- checkBuf$digiStatus    # The cell is locked for digitizing.
Cbuff <- checkBuf$buffStatus    # The cell is locked for buffering.
Cdone <- checkBuf$doneStatus    # The cell has been digitized and reconciled, if necessary.
#   ---- Check.  The cell cannot currently be out for digitizing or buffering.
Cvalid <-  !Cdigi & !Cbuff     # Want:     0  &  0
nCValid <- length(Cvalid[Cvalid == TRUE])
#   ---- Actually do the check.
require(rgeos)
theFolder <- tblFolders[tblFolders$Grid_ID == theNext,]
theRange <- theFolder$Range
#   ---- Pull Grid_IDs that are to buffer the new Grid_ID.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
shpBuf <- makeBuffer(shpObj,cell=theNext,radius=2.5,cellDim.m=3218.69,inner=TRUE)
shpBuf <- shpBuf[shpBuf@data$Grid_ID != theNext,]
shpGID <- makeBuffer(shpObj,cell=theNext,radius=1.0,cellDim.m=3218.69,inner=TRUE)
#   ---- Make sure we have no Out-for-Digitizing Grid_IDs in the selected
#   ---- Grid_ID's buffer.  Note that buff indicator used above is the set
#   ---- of buffering cells UP to this possibly new cell.
checkBuf <- master[master$Grid_ID %in% shpBuf@data$Grid_ID,]
#   ---- We now need to ensure all cells are available.
Copen <- checkBuf$openStatus    # The cell still needs to be digitized.
Cdigi <- checkBuf$digiStatus    # The cell is locked for digitizing.
Cbuff <- checkBuf$buffStatus    # The cell is locked for buffering.
Cdone <- checkBuf$doneStatus    # The cell has been digitized and reconciled, if necessary.
#   ---- Check.  The cell cannot currently be out for digitizing or buffering.
Cvalid <-  !Cdigi & !Cbuff     # Want:     0  &  0
nCValid <- length(Cvalid[Cvalid == TRUE])
#   ---- Actually do the check.
plot(shpBuf)
dim(raster(shpBuf))
raster(shpBuf)
slotNames(shpBuf)
shpBuf@bbox
xExtent <- shpBuf@bbox[1,2] - shpBuf@bbox[1,1]
yExtent <- shpBuf@bbox[2,2] - shpBuf@bbox[2,1]
ratio <- xExtent <- yExtent
ratio
xExtent <- shpBuf@bbox[1,2] - shpBuf@bbox[1,1]
yExtent <- shpBuf@bbox[2,2] - shpBuf@bbox[2,1]
ratio <- xExtent - yExtent
ratio
xExtent
yExtent
xExtent / yExtent
(shpBuf@bbox[1,2] - shpBuf@bbox[1,1]) / 2
(shpBuf@bbox[2,2] - shpBuf@bbox[2,1]) / 3
r <- raster(extent(shpGID@bbox),nrow=-10,ncol=-10,crs=shpBuf@proj4string)
plot(r)
help(raster)
help(gBuffer)
r <- raster(extent(gBuffer(shpGID@bbox,width=cellUnit)),nrow=15,ncol=15,crs=shpBuf@proj4string)
r <- raster(extent(gBuffer(shpGID,width=cellUnit)),nrow=15,ncol=15,crs=shpBuf@proj4string)
cellUnit <- 3218.694
r <- raster(extent(gBuffer(shpGID,width=cellUnit)),nrow=15,ncol=15,crs=shpBuf@proj4string)
plot(r)
r[] <- 1:ncell(r)
miniGrid <- as(r, "SpatialPolygonsDataFrame")
miniGrid <- as(miniGrid,"SpatialLinesDataFrame")
miniGrid <- spTransform(miniGrid,CRS(projAEAc))
plot(miniGrid)
plot(shpGID,add=TRUE,col="red")
plot(shpBuf,add=TRUE,col="yellow")
theFolder
#   ---- Determine length in meters of one cell; i.e., transect length.
cellUnit <- 3218.694
#   ---- Make a mini-grid shapefile of the buffer region for placement
#   ---- into the theNext folder.  Currently assumes a 3x3 big local grid.
r <- raster(extent(gBuffer(shpGID,width=cellUnit)),nrow=15,ncol=15,crs=shpBuf@proj4string)
#r <- raster(extent(shpBuf@bbox),nrow=15,ncol=15,crs=shpBuf@proj4string)
r[] <- 1:ncell(r)
miniGrid <- as(r, "SpatialPolygonsDataFrame")
miniGrid <- as(miniGrid,"SpatialLinesDataFrame")
miniGrid <- spTransform(miniGrid,CRS(projAEAc))
writeOGR(miniGrid,paste0("//lar-file-srv/Data/BTPD_2016/Digitizing/",theFolder$Range,"/",theNext),paste0("LocalMiniGrid_",theNext),overwrite_layer=TRUE,driver="ESRI Shapefile")
checkCellValidity('pJason_Towns_CO165389')
checkInCell('CO165389',100)
getStatus("All")
checkOutCell(100)
install.packages("L:/BTPD_2016/pDog Package/Pre-release Version/pDog_0.2.zip", repos = NULL, type = "win.binary")
require(pDog)
checkOutCell(100)
checkCellValidity('pJason_Towns_CO111898')
checkCellValidity('pJason_Towns_CO111898')
checkInCell('CO111898',100)
getStatus("All")
tblNames
#   ---- Find the user.
tblNames <- read.csv(paste0(tblDir,"tblNames.csv"))
tblNamesUserID <- tblNames[tblNames$userID == userID,]
#   ---- Check user status and active status.
if( nrow(tblNamesUserID) == 0 ){
stop("The userID submitted was not found.  Try again.",call.=FALSE)
} else if( nrow(tblNamesUserID) == 1 & (tblNamesUserID$doubleActive == 0 & tblNamesUserID$singleActive == 0 ){
stop("The userID submitted was found but is inactive.  Try again.",call.=FALSE)
}
tblDir="//lar-file-srv/Data/BTPD_2016/Analysis/Database/"
#   ---- Find the user.
tblNames <- read.csv(paste0(tblDir,"tblNames.csv"))
tblNamesUserID <- tblNames[tblNames$userID == userID,]
#   ---- Check user status and active status.
if( nrow(tblNamesUserID) == 0 ){
stop("The userID submitted was not found.  Try again.",call.=FALSE)
} else if( nrow(tblNamesUserID) == 1 & (tblNamesUserID$doubleActive == 0 & tblNamesUserID$singleActive == 0 ){
stop("The userID submitted was found but is inactive.  Try again.",call.=FALSE)
}
#   ---- Find the user.
tblNames <- read.csv(paste0(tblDir,"tblNames.csv"))
tblNamesUserID <- tblNames[tblNames$userID == userID,]
userID <- 100
#   ---- Find the user.
tblNames <- read.csv(paste0(tblDir,"tblNames.csv"))
tblNamesUserID <- tblNames[tblNames$userID == userID,]
#   ---- Check user status and active status.
if( nrow(tblNamesUserID) == 0 ){
stop("The userID submitted was not found.  Try again.",call.=FALSE)
} else if( nrow(tblNamesUserID) == 1 & (tblNamesUserID$doubleActive == 0 & tblNamesUserID$singleActive == 0 ){
stop("The userID submitted was found but is inactive.  Try again.",call.=FALSE)
}
#   ---- Check user status and active status.
if( nrow(tblNamesUserID) == 0 ){
stop("The userID submitted was not found.  Try again.",call.=FALSE)
} else if( nrow(tblNamesUserID) == 1 & (tblNamesUserID$doubleActive == 0 & tblNamesUserID$singleActive == 0) ){
stop("The userID submitted was found but is inactive.  Try again.",call.=FALSE)
}
checkUser(912)
checkUser <- function(userID,tblDir="//lar-file-srv/Data/BTPD_2016/Analysis/Database/"){
# userID <- 102
# tblDir <- "//lar-file-srv/Data/BTPD_2016/Analysis/Database/"
#   ---- Find the user.
tblNames <- read.csv(paste0(tblDir,"tblNames.csv"))
tblNamesUserID <- tblNames[tblNames$userID == userID,]
#   ---- Check user status and active status.
if( nrow(tblNamesUserID) == 0 ){
stop("The userID submitted was not found.  Try again.",call.=FALSE)
} else if( nrow(tblNamesUserID) == 1 & (tblNamesUserID$doubleActive == 0 & tblNamesUserID$singleActive == 0) ){
stop("The userID submitted was found but is inactive.  Try again.",call.=FALSE)
}
tblNames
}
checkUser(912)
tblFolders[tblFolders$userID == userID,]$doubleActive
tblFolders <- getFolderStatus()
doubleActive <- tblFolders[tblFolders$userID == userID,]$doubleActive
getFolderStatus <- function(tblDir="//lar-file-srv/Data/BTPD_2016/Analysis/Database/"){
# tblDir <- "//lar-file-srv/Data/BTPD_2016/Analysis/Database/"
folder <- read.table(paste0(tblDir,"tblFolders.csv"),stringsAsFactors=FALSE,sep=",",header=TRUE)
folder
}
tblFolders <- getFolderStatus()
doubleActive <- tblFolders[tblFolders$userID == userID,]$doubleActive
doubleActive
userID
tblFolders
tblFolders[tblFolders$userID == userID,]$doubleActive
tblFolders[tblFolders$userID == userID,]
tblNames[tblNames$userID == userID,]$doubleActive
singleActive <- tblNames[tblNames$userID == userID,]$singleActive
singleActive
doubleActive
doubleActive <- tblNames[tblNames$userID == userID,]$doubleActive
doubleActive
userID <- 912
tblNames[tblNames$userID == userID,]$singleActive
tblNames[tblNames$userID == userID,]$doubleActive
head(master)
#   ---- Define useful projections.
projAEAc  <- '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0'
#   ---- Check to make sure user is legitimate.
tblNames <- checkUser(userID)
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == userID,]$FirstName))
singleActive <- tblNames[tblNames$userID == userID,]$singleActive
doubleActive <- tblNames[tblNames$userID == userID,]$doubleActive
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
assign$digiStartTime <- as.POSIXlt(assign$digiStartTime,tz="America/Denver")
assign$digiEndTime <- as.POSIXlt(assign$digiEndTime,tz="America/Denver")
assign$buffStartTime <- as.POSIXlt(assign$buffStartTime,tz="America/Denver")
assign$buffEndTime <- as.POSIXlt(assign$buffEndTime,tz="America/Denver")
getCellStatus <- function(tblDir="//lar-file-srv/Data/BTPD_2016/Analysis/Database/"){
# tblDir <- "//lar-file-srv/Data/BTPD_2016/Analysis/Database/"
#   #   ---- Find out where each cell is in the directory.
#   beg <- Sys.time()
#   filenames <- list.files(tblDir,pattern="*.csv",full.names=TRUE,recursive=TRUE)
#   dat <- lapply(filenames, function(x) read.csv(x,header=FALSE))
#   dat <- data.frame(lapply(data.frame(t(sapply(dat, `[`))), unlist))
#   end <- Sys.time()
#
#   time <- end - beg
#   time
assign <- read.table(paste0(tblDir,"tblCellStatus.csv"),stringsAsFactors=FALSE,sep=",",header=TRUE)
assign
}
getRankStatus <- function(tblDir="//lar-file-srv/Data/BTPD_2016/Analysis/Database/"){
# tblDir <- "//lar-file-srv/Data/BTPD_2016/Analysis/Database/"
ranks <- read.csv(paste0(tblDir,"tblSampling.csv"))
ranks
}
#' @export makeBuffer
#'
#' @author Jason Mitchell (jmitchell@@west-inc.com)
#'
#' @seealso \code{\link{gBuffer}}, \code{\link{gIntersects}},
#'   \code{\link{gIntersection}}
makeBuffer <- function(shp,cell,radius=2.5,cellDim.m=3218.69,inner=TRUE){
# shp <- allShps[[2]]
# cell <- "CO132952"
# radius <- 2.5
# cellDim.m <- 3218.69
# inner <- TRUE
#   ---- Make sure the rownames of attribute data in shp match the polygonal IDs.
rownames(shp@data) <- sapply(shp@polygons,function(x) slot(x,"ID"))
#   ---- Make the buffering circle.
center <- gCentroid(shp[shp@data$Grid_ID == cell,])
circle <- gBuffer(center,byid=TRUE,width=radius*cellDim.m)
#   ---- Identify set of possible outer safety cells.
safetyOuterVec <- rownames(gIntersects(circle,shp,byid=TRUE))[gIntersects(circle,shp,byid=TRUE) == TRUE]
#   ---- Restrict the outer safety cells to their own object.
safetyOuter <- shp[rownames(shp@data) %in% safetyOuterVec,]
#   ---- Identify the inner safety cells with cells entirely in circle.
#   ---- Do this by seeing that 4 square miles = 10359994 square meters.
preSafetyInnerVec <- gArea(gIntersection(circle,safetyOuter,byid=TRUE),byid=TRUE) >= 10359993
safetyInnerVec <- unlist(strsplit(names(preSafetyInnerVec[preSafetyInnerVec == TRUE])," ",fixed=TRUE))[c(FALSE,TRUE)]
#   ---- Restrict the inner safety cells to their own object.
safetyInner <- shp[rownames(shp@data) %in% safetyInnerVec,]
if( inner == TRUE){
ans <- safetyInner
} else {
ans <- safetyOuter
}
ans
#   plot(shp)
#   plot(shp[shp@data$dblSamp == 1,],add=TRUE,col='red')
#   plot(circle,col="blue")
#   plot(safetyOuter,add=TRUE,col="green")
#   plot(safetyInner,add=TRUE,col="brown")
}
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
assign$digiStartTime <- as.POSIXlt(assign$digiStartTime,tz="America/Denver")
assign$digiEndTime <- as.POSIXlt(assign$digiEndTime,tz="America/Denver")
assign$buffStartTime <- as.POSIXlt(assign$buffStartTime,tz="America/Denver")
assign$buffEndTime <- as.POSIXlt(assign$buffEndTime,tz="America/Denver")
anyOpen <- assign[assign$digiStatus == 1 & assign$digiUser == userID & assign$digiPartner == 998,]
if(nrow(anyOpen) > 0){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
stop("Records indicate you have checked out singly digitized cell ",anyOpen[1,]$Grid_ID,".  Finish and close it, and then try again.")
}
#   ---- Get the BAS rankings.
ranks <- getRankStatus()
#   ---- Make a master data frame.
master <- merge(assign,ranks,by=c("Grid_ID"),all.x=TRUE,all.y=TRUE)
master <- master[order(master$digiStatus,master$sampleID),]
#   ---- A safeguard to ensure we have all 11,101 records.
nTotal <- nrow(master)
if( !(nTotal == 11101) ){
warning("Creation of data frame master does not have the correct number of records.  Investigate")
stop
}
#   ---- Get the big grid so we can subset to the buffer below.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
require(rgdal)
anyOpen <- assign[assign$digiStatus == 1 & assign$digiUser == userID & assign$digiPartner == 998,]
if(nrow(anyOpen) > 0){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
stop("Records indicate you have checked out singly digitized cell ",anyOpen[1,]$Grid_ID,".  Finish and close it, and then try again.")
}
#   ---- Get the BAS rankings.
ranks <- getRankStatus()
#   ---- Make a master data frame.
master <- merge(assign,ranks,by=c("Grid_ID"),all.x=TRUE,all.y=TRUE)
master <- master[order(master$digiStatus,master$sampleID),]
#   ---- A safeguard to ensure we have all 11,101 records.
nTotal <- nrow(master)
if( !(nTotal == 11101) ){
warning("Creation of data frame master does not have the correct number of records.  Investigate")
stop
}
#   ---- Get the big grid so we can subset to the buffer below.
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
#   ---- Get the big grid so we can subset to the buffer below.
shpDir <- "//lar-file-srv/Data/BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_CO_Ranked"
shp <- "BTPD_Grid_CO_Ranked"
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
#   ---- We now need to find a cell whose buffer is available.
open <- master$openStatus    # The cell still needs to be digitizing.
digi <- master$digiStatus    # The cell is locked for digitizing.
buff <- master$buffStatus    # The cell is locked for buffering.
done <- master$doneStatus    # The cell has been digitized and reconciled, if necessary.
head(master)
doub <- master$dblSamp
head(doub)
valid <- open & !digi & !buff & !done & !doub
length(valid)
doubleActive
userID
valid <- open & !digi & !buff & !done & !doub
table(valid)
userID <- 100
tblNames <- checkUser(userID)
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == userID,]$FirstName))
singleActive <- tblNames[tblNames$userID == userID,]$singleActive
doubleActive <- tblNames[tblNames$userID == userID,]$doubleActive
doubleActive
valid <- open & !digi & !buff & !done & !doub
table(valid)
userID <- 912
#   ---- Check to make sure user is legitimate.
tblNames <- checkUser(userID)
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == userID,]$FirstName))
singleActive <- tblNames[tblNames$userID == userID,]$singleActive
doubleActive <- tblNames[tblNames$userID == userID,]$doubleActive
doubleActive
doubleActive == 1
valid <- open & !digi & !buff & !done
table(valid)
valid <- open & !digi & !buff & !done & !doub
table(valid)
doubleActive
nValid <- length(valid[valid == TRUE])
nValid
sum(open) == 0 & sum(digi) == 0 & sum(buff) == 0 & sum(done) == nTotal
sum(open) == 0 & sum(buff) > 0 & sum(done) != nTotal
nValid > 0
