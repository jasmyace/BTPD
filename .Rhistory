#       #   ---- Get theDoublyActives not in theUsers.
#       theNewOnes <- theDoublyActives[!(theDoublyActives %in% theUsers)]
#
#       #   ---- If we have a new user, add them to the list of possibilities.
#       if( length(theNewOnes) > 0){
#         theNewUsers <- NULL
#         for(i in 1:length(theNewOnes)){
#           if(userIDAssign == "Secondary"){
#             thisNewUser <- data.frame(digiPrimary=theNewOnes[i],digiSecondary=userID,Freq=0,Row=0,Col=0,Diag=0,Upper=0,Lower=0)
#           } else {
#             thisNewUser <- data.frame(digiPrimary=userID,digiSecondary=theNewOnes[i],Freq=0,Row=0,Col=0,Diag=0,Upper=0,Lower=0)
#           }
#           theNewUsers <- rbind(theNewUsers,thisNewUser)
#         }
#         userBalance <- rbind(userBalance,theNewUsers)
#       }
#       userBalance <- userBalance[order(userBalance$Freq),]
#       theLowRank <- userBalance$Freq[1]
#       userBalanceLowRank <- userBalance[userBalance$Freq == theLowRank,]
#
#       if( nrow(userBalanceLowRank) > 1 ){
#
#         #   ---- We have a tie.  Choose one randomly, formatting as we go. Don't choose
#         #   ---- the userID!
#       theOptions <- userBalance[userBalance$Freq == theLowRank,]
#       theOptionsDF <- data.frame(theOptions=unique(c(theOptions$digiPrimary,theOptions$digiSecondary)))
#       theOptionsDF$RUnif <- runif(nrow(theOptionsDF))
#       thePartnerAssign <- theOptionsDF[theOptionsDF$theOptions != userID,]$theOptions[1]
#
#       } else {
#
#         #   ---- No tie.  Make sure we don't choose the userID, and format as well.
#         theOptions <- userBalance[1,]
#         theOptionsVec <- unique(c(theOptions$digiPrimary,theOptions$digiSecondary))
#         thePartnerAssign <- theOptionsVec[theOptionsVec != userID]
#       }
#     }
#
#
#   assignInfo <- data.frame(userID=userID,
#                            primaryProp=primaryProp,
#                            secondaryProp=secondaryProp,
#                            userIDAssign=userIDAssign,
#                            theLowRank=theLowRank,
#                            thePartnerAssign=thePartnerAssign)
return(assignInfo)
}
#   ---- Note that we already check for at least two digitizers above.
assignInfo <- tryCatch(
{
balanceAssign(userID,assign=assign,tblNames=tblNames,partnerValid=partnerValid$userID)
},
error=function(condAI){
message("Something is wrong with the balanceAssign function.  Investigate.\n")
message("Here's the original error message:\n")
message(condAI)
# Choose a return value in case of error
return(NA)
}
)
assignInfo
class(assignInfo$thePartnerAssign)
balanceAssign <- function(userID,assign,tblNames,partnerValid){
#  userID <- 873
#  partnerValid <- partnerValid$userID
#   ---- Restrict to the doubly assigned.  We use these to get frequencies
#   ---- of what's been done so far.
doubles <- assign[ !is.na(assign$digiDouble) & assign$digiDouble == 1,]
#   ---- Identify the unique users up to this point.  Note that partnerValid
#   ---- excludes the userID by default, but theUsers includes userID.
theUsers <- unique(c(doubles$digiPrimary,doubles$digiSecondary))
theUsers <- c(theUsers[theUsers %in% partnerValid],userID)
#   ---- Identify the options of assigning a partner.
theDoublyActives <- c(tblNames[tblNames$doubleActive == 1 & tblNames$userID != userID,]$userID)
theDoublyActives <- theDoublyActives[theDoublyActives %in% partnerValid]
#   ---- Count up the unique instances of users.  Call it 'Dim' since it forms
#   ---- a square matrix, c.f. the table called below, prior to being pushed
#   ---- into a data frame.  We combine these two to allow new users into the mix.
#   ---- They enter via theDoublyActives.  They can never ben in theUsers.
allOptions <- unique(c(theDoublyActives,theUsers))
Dim <- length(allOptions)
#   ---- Pretty up the list output from the table.
#   ---- This is roundabout, but when we have a new user, that user can only be
#   ---- one of primary or secondary.  This means the table is non-square.  But
#   ---- everything assumes that it is.  So, hijack everything to ensure that
#   ---- the code that assumes that fact still works, even when it's not true.
# balance <- as.data.frame(table(doubles$digiPrimary,doubles$digiSecondary))
#   ---- Make the square matrix, based on the number of distinct users.
balance <- matrix(NA,nrow=Dim,ncol=Dim)
rownames(balance) <- allOptions
colnames(balance) <- allOptions
#   ---- Count the number of instances.  This emulates the table function.
for( i in 1:Dim ){
for (j in 1:Dim ){
balance[i,j] <- sum(doubles$digiPrimary == allOptions[i] & doubles$digiSecondary == allOptions[j])
}
}
#   ---- This emulates the table-to-date-frame functionality.
balance <- as.data.frame(as.table(balance))
#   ---- Now, we continue on as we did before.
names(balance)[names(balance) == "Var1"] <- "digiPrimary"
names(balance)[names(balance) == "Var2"] <- "digiSecondary"
balance$Row <- rep(seq(1,Dim,1),Dim)
balance$Col <- balance$Row[order(balance$Row)]
#   ---- Identify the parts of the original matrix in the list of rows
#   ---- we now have from the original table.
balance$Diag <- ifelse(balance$Row == balance$Col,1,0)
balance$Upper <- ifelse(balance$Row < balance$Col,1,0)
balance$Lower <- ifelse(balance$Row > balance$Col,1,0)
#   ---- The userID is the one pulling the cell, and that person must be either
#   ---- primary or secondary.  So, reduce to that person's data.  But also
#   ---- get rid of the diagonals while we're at it.  Note that the upper triangular
#   ---- region of the original matrix holds PRIMARY, while the lower triangular
#   ---- region of the original matrix holds SECONDARY.
assignBalance <- balance[(balance$digiPrimary == userID | balance$digiSecondary == userID) & balance$Diag == 0,]
#   ---- Sort by the userID's Freq counts.  The lower number is the data for
#   ---- we want to assign people.
assignBalance <- assignBalance[order(assignBalance$Freq),]
if(assignBalance[1,]$digiPrimary == userID){
userIDAssign <- "Primary"
thePartnerAssign <- as.character(droplevels(assignBalance[1,]$digiSecondary))
} else {
userIDAssign <- "Secondary"
thePartnerAssign <- as.character(droplevels(assignBalance[1,]$digiPrimary))
}
assignInfo <- data.frame(userID=userID,
userIDAssign=userIDAssign,
thePartnerAssign=thePartnerAssign)
#
#
#   #   ---- Check if we have a new user.
#   if( sum(assignBalance$Freq) == 0 ){
#     primaryProp <- 0
#     secondaryProp <- 0
#   } else {
#     primaryProp <- sum(assignBalance[assignBalance$digiPrimary == userID,]$Freq) / sum(assignBalance$Freq)
#     secondaryProp <- sum(assignBalance[assignBalance$digiSecondary == userID,]$Freq) / sum(assignBalance$Freq)
#   }
#
#   #   ---- Given the proportion of primary and secondary, assign the userID to be
#   #   ---- the type of digitizer with less.  This helps balance out that userID's
#   #   ---- assignments, given his/her assignments so far.  Note that I don't
#   #   ---- randomly assign in the case of a tie...I just assign those to secondary.
#   #   ---- This is because I allow for the greater than or equal.
#   userIDAssign <- ifelse(primaryProp >= secondaryProp,'Secondary','Primary')
#
#   if(userIDAssign == "Secondary"){
#
#     #   ---- Reduce to the lower triangular matrix.
#     userBalance <- assignBalance[assignBalance$Lower == 1,]
#
#   } else {
#
#     #   ---- Reduce to the upper triangular matrix.
#     userBalance <- assignBalance[assignBalance$Upper == 1,]
#   }
#
#
#
#
#     #   ---- Get the coupling records for primary.
#     theOptions <- as.data.frame(table(doubles$digiPrimary))
#
#     #   ---- Reduce the options to those currently active in tblNames.  We should have
#     #   ---- at least one because we check for at least the availability of two doubly
#     #   ---- digitizers before we enter the function.
#
#     #   ---- Check if
#     theOptions$Var1 %in% theDoublyActives
#
#     theOptions <- theOptions[theOptions$Var1 %in% theDoublyActives,]
#     thePartnerAssign <- theOptions[order(theOptions$Freq),]$Var1[1]
#     thePartnerAssign <- as.numeric(levels(thePartnerAssign))[thePartnerAssign]
#     theLowRank <- theOptions[order(theOptions$Freq),]$Freq[1]
#   } else {
#
#       #   ---- Adjust factors levels to what they should be.
#       userBalance$digiPrimary <- as.numeric(levels(userBalance$digiPrimary))[userBalance$digiPrimary]
#       userBalance$digiSecondary <- as.numeric(levels(userBalance$digiSecondary))[userBalance$digiSecondary]
#
#       #   ---- Now, the idea is make the partner with the less number of pairings with
#       #   ---- the userID the partner.  But, we could have a tie. Who do we choose then?
#       #   ---- Let's just keep things simple and choose randomly.  We could look at other
#       #   ---- frequency tables, and choose the person with the least examined cells
#       #   ---- overall, etc.  Finally, we must consider the possibility that there is a
#       #   ---- new userID in the list of doubleAssign that hasn't actually digitized a
#       #   ---- doubly cell yet.  This individual will not be in theUsers, but will be
#       #   ---- in theDoublyActives.
#
#       #   ---- Get theDoublyActives not in theUsers.
#       theNewOnes <- theDoublyActives[!(theDoublyActives %in% theUsers)]
#
#       #   ---- If we have a new user, add them to the list of possibilities.
#       if( length(theNewOnes) > 0){
#         theNewUsers <- NULL
#         for(i in 1:length(theNewOnes)){
#           if(userIDAssign == "Secondary"){
#             thisNewUser <- data.frame(digiPrimary=theNewOnes[i],digiSecondary=userID,Freq=0,Row=0,Col=0,Diag=0,Upper=0,Lower=0)
#           } else {
#             thisNewUser <- data.frame(digiPrimary=userID,digiSecondary=theNewOnes[i],Freq=0,Row=0,Col=0,Diag=0,Upper=0,Lower=0)
#           }
#           theNewUsers <- rbind(theNewUsers,thisNewUser)
#         }
#         userBalance <- rbind(userBalance,theNewUsers)
#       }
#       userBalance <- userBalance[order(userBalance$Freq),]
#       theLowRank <- userBalance$Freq[1]
#       userBalanceLowRank <- userBalance[userBalance$Freq == theLowRank,]
#
#       if( nrow(userBalanceLowRank) > 1 ){
#
#         #   ---- We have a tie.  Choose one randomly, formatting as we go. Don't choose
#         #   ---- the userID!
#       theOptions <- userBalance[userBalance$Freq == theLowRank,]
#       theOptionsDF <- data.frame(theOptions=unique(c(theOptions$digiPrimary,theOptions$digiSecondary)))
#       theOptionsDF$RUnif <- runif(nrow(theOptionsDF))
#       thePartnerAssign <- theOptionsDF[theOptionsDF$theOptions != userID,]$theOptions[1]
#
#       } else {
#
#         #   ---- No tie.  Make sure we don't choose the userID, and format as well.
#         theOptions <- userBalance[1,]
#         theOptionsVec <- unique(c(theOptions$digiPrimary,theOptions$digiSecondary))
#         thePartnerAssign <- theOptionsVec[theOptionsVec != userID]
#       }
#     }
#
#
#   assignInfo <- data.frame(userID=userID,
#                            primaryProp=primaryProp,
#                            secondaryProp=secondaryProp,
#                            userIDAssign=userIDAssign,
#                            theLowRank=theLowRank,
#                            thePartnerAssign=thePartnerAssign)
return(assignInfo)
}
#   ---- Note that we already check for at least two digitizers above.
assignInfo <- tryCatch(
{
balanceAssign(userID,assign=assign,tblNames=tblNames,partnerValid=partnerValid$userID)
},
error=function(condAI){
message("Something is wrong with the balanceAssign function.  Investigate.\n")
message("Here's the original error message:\n")
message(condAI)
# Choose a return value in case of error
return(NA)
}
)
assignInfo
class(assignInfo)
class(assignInfo$thePartnerAssign)
assignInfo$thePartnerAssign <- as.character(droplevels(assignInfo$thePartnerAssign))
assignInfo
class(assignInfo$thePartnerAssign)
#   ---- Method 2:  assign Primary and Secondary based on balancing.
if( assignInfo$userIDAssign == "Primary" ){
assign[assign$Grid_ID == theNext,]$digiPrimary <- assignInfo$userID
assign[assign$Grid_ID == theNext,]$digiSecondary <- assignInfo$thePartnerAssign
#   ---- We may have swapped which names go with which role:  primary and
#   ---- secondary.  Set this explicitly to be sure.
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == assignInfo$userID,]$FirstName))
sFirstName <- as.character(droplevels(tblNames[tblNames$userID == assignInfo$thePartnerAssign,]$FirstName))
} else {
assign[assign$Grid_ID == theNext,]$digiPrimary <- assignInfo$thePartnerAssign
assign[assign$Grid_ID == theNext,]$digiSecondary <- assignInfo$userID
#   ---- We may have swapped which names go with which role:  primary and
#   ---- secondary.  Set this explicitly to be sure.
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == assignInfo$thePartnerAssign,]$FirstName))
sFirstName <- as.character(droplevels(tblNames[tblNames$userID == assignInfo$userID,]$FirstName))
}
assign[assign$Grid_ID == theNext,]
double == 1
#   ---- The function sample is weird when you only want one.  So go a different route.
partnerValid <- tblNames[tblNames$doubleActive == 1 & tblNames$userID != userID,]
# partnerValid <- tblNames[tblNames$userID %in% c(219),]    #   ---- This is here for testing.
if(nrow(partnerValid) == 0){
stop("Possibly only one digitizer is active for partnering.  Investigate.")
}
doublyMethod <- 2
#   ---- Note that we already check for at least two digitizers above.
assignInfo <- tryCatch(
{
balanceAssign(userID,assign=assign,tblNames=tblNames,partnerValid=partnerValid$userID)
},
error=function(condAI){
message("Something is wrong with the balanceAssign function.  Investigate.\n")
message("Here's the original error message:\n")
message(condAI)
# Choose a return value in case of error
return(NA)
}
)
assignInfo$thePartnerAssign <- as.character(droplevels(assignInfo$thePartnerAssign))
#   ---- Method 2:  assign Primary and Secondary based on balancing.
if( assignInfo$userIDAssign == "Primary" ){
assign[assign$Grid_ID == theNext,]$digiPrimary <- assignInfo$userID
assign[assign$Grid_ID == theNext,]$digiSecondary <- assignInfo$thePartnerAssign
#   ---- We may have swapped which names go with which role:  primary and
#   ---- secondary.  Set this explicitly to be sure.
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == assignInfo$userID,]$FirstName))
sFirstName <- as.character(droplevels(tblNames[tblNames$userID == assignInfo$thePartnerAssign,]$FirstName))
} else {
assign[assign$Grid_ID == theNext,]$digiPrimary <- assignInfo$thePartnerAssign
assign[assign$Grid_ID == theNext,]$digiSecondary <- assignInfo$userID
#   ---- We may have swapped which names go with which role:  primary and
#   ---- secondary.  Set this explicitly to be sure.
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == assignInfo$thePartnerAssign,]$FirstName))
sFirstName <- as.character(droplevels(tblNames[tblNames$userID == assignInfo$userID,]$FirstName))
}
assign[assign$Grid_ID == theNext,]
#   ---- Update the record set with the fact this is a doubly cell.  Do this after the
#   ---- fact, since we use assign in doublyMethod == 2.
assign[assign$Grid_ID == theNext,]$digiSingle <- 0
assign[assign$Grid_ID == theNext,]$digiDouble <- 1
theTwoDigis <- c(assignInfo$userID,assignInfo$thePartnerAssign)
partner <- theTwoDigis[theTwoDigis != userID]
assign[assign$Grid_ID == theNext,]$digiPartner <- partner
assign[assign$Grid_ID == theNext,]
install.packages("L:/BTPD_2016/Analysis/pDog_0.8.4.6.zip", repos = NULL, type = "win.binary")
require(pDog)
getStatus("All")
detach("package:pDog", unload=TRUE)
install.packages("L:/BTPD_2016/Analysis/pDog_0.8.4.6.zip", repos = NULL, type = "win.binary")
require(pDog)
getStatus("All")
4547/11101
getStatus(807)
getStatus(361)
getStatus(219)
getStatus(219)
userSummary()
userSummary(summary="Double")
#   ---- Get the current list of who has what.
assign <- getCellStatus()
#   ---- Get users.
tblNames <- checkUser(userID=100)
tblNames <- tblNames[!(tblNames$userID %in% c(437,798,998,999)),]
names(tblNames)[names(tblNames) == 'userID'] <- 'digiUserID'
assign <- merge(assign,tblNames[,c('digiUserID','FirstName')],by=c('digiUserID'),all.x=TRUE)
assign <- assign[order(assign$Grid_ID),]
assign$digiStartTime <- as.POSIXlt(strptime(assign$digiStartTime,format="%m/%d/%Y %H:%M"),tz="America/Denver")
assign$digiEndTime <- as.POSIXlt(strptime(assign$digiEndTime,format="%m/%d/%Y %H:%M"),tz="America/Denver")
times <- assign[assign$doneStatus == 1,]
times$diffTimeHrs <- as.numeric(difftime(times$digiEndTime,times$digiStartTime) / 60 / 60)
#   ---- DEVELOP A SIMPLE REPORT FOR SINGLES.
getCellStatus <- function(tblDir="//lar-file-srv/Data/BTPD_2016/Analysis/Database/"){
# tblDir <- "//lar-file-srv/Data/BTPD_2016/Analysis/Database/"
assign <- read.table(paste0(tblDir,"tblCellStatus.csv"),stringsAsFactors=FALSE,sep=",",header=TRUE)
assign
}
#   ---- Get the current list of who has what.
assign <- getCellStatus()
checkUser <- function(userID,tblDir="//lar-file-srv/Data/BTPD_2016/Analysis/Database/"){
# userID <- 102
# tblDir <- "//lar-file-srv/Data/BTPD_2016/Analysis/Database/"
#   ---- Find the user.
tblNames <- read.csv(paste0(tblDir,"tblNames.csv"))
tblNamesUserID <- tblNames[tblNames$userID == userID,]
#   ---- Check user status and active status.
if( nrow(tblNamesUserID) == 0 ){
stop("The userID submitted was not found.  Try again.",call.=FALSE)
} else if( nrow(tblNamesUserID) == 1 & (tblNamesUserID$doubleActive == 0 & tblNamesUserID$singleActive == 0) ){
stop("The userID submitted was found but is inactive.  Try again.",call.=FALSE)
}
tblNames
}
#   ---- Get users.
tblNames <- checkUser(userID=100)
tblNames <- tblNames[!(tblNames$userID %in% c(437,798,998,999)),]
names(tblNames)[names(tblNames) == 'userID'] <- 'digiUserID'
assign <- merge(assign,tblNames[,c('digiUserID','FirstName')],by=c('digiUserID'),all.x=TRUE)
assign <- assign[order(assign$Grid_ID),]
assign$digiStartTime <- as.POSIXlt(strptime(assign$digiStartTime,format="%m/%d/%Y %H:%M"),tz="America/Denver")
assign$digiEndTime <- as.POSIXlt(strptime(assign$digiEndTime,format="%m/%d/%Y %H:%M"),tz="America/Denver")
times <- assign[assign$doneStatus == 1,]
times$diffTimeHrs <- as.numeric(difftime(times$digiEndTime,times$digiStartTime) / 60 / 60)
times2 <- times
#   ---- Keep only doubles.
times2 <- times2[times2$digiDouble == 1,]
#   ---- Keep only non-errors.
times2 <- times2[times2$jErrStatus == 0,]
#   ---- Get names for the partners.
names(tblNames)[names(tblNames) == "digiUserID"] <- "digiPartner"
names(times2)[names(times2) == "FirstName"] <- "digiFirst"
times2 <- merge(times2,tblNames[,c('digiPartner','FirstName')],by=c("digiPartner"),all.x=TRUE)
names(times2)[names(times2) == "FirstName"] <- "PartnerFirst"
times2 <- times2[order(times2$Grid_ID),]
times2$digiEndTimeAsDate <- as.Date(times2$digiEndTime)
times2$digiEndTimeAsDate2 <- paste0(times2$digiEndTimeAsDate,"-",weekdays(as.Date(times2$digiEndTime,format="%Y/%m/%d")))
times2$digiFirst <- as.character(droplevels(times2$digiFirst))
times2$PartnerFirst <- as.character(droplevels(times2$PartnerFirst))
timesMatA <- as.data.frame.matrix(table(times2$digiEndTimeAsDate2,times2$digiFirst))
timesMatA2 <- cbind(timesMatA,rowSums(timesMatA))
timesMatA3 <- rbind(timesMatA2,colSums(timesMatA2))
rownames(timesMatA3)[dim(timesMatA3)[1]] <- ""
colnames(timesMatA3)[dim(timesMatA3)[2]] <- "Total"
timesMatB <- as.data.frame.matrix(table(times2$digiEndTimeAsDate2,times2$PartnerFirst))
timesMatB2 <- cbind(timesMatB,rowSums(timesMatB))
timesMatB3 <- rbind(timesMatB2,colSums(timesMatB2))
rownames(timesMatB3)[dim(timesMatB3)[1]] <- ""
colnames(timesMatB3)[dim(timesMatB3)[2]] <- "Total"
timesMatA3
timesMatB3
timesMatA3 + timesMatB3
colnames(timesA3)
colnames(timesMatA3)
sort(c(colnames(timesMatA3),colnames(timesMatB3)))
unique(sort(c(colnames(timesMatA3),colnames(timesMatB3))))
help(sort)
allPeeps <- unique(sort(c(colnames(timesMatA3),colnames(timesMatB3))))
allPeeps <- allPeeps[allPeeps != "Total"]
allPeeps
class(timesMatA3)
rep(0,nrow(timesMatA3))
colnames(timesMatA3)
for(i in 1:(length(colnames(timesMatA3)) - 1){
if( !(colnames(timesMatA3)[i] %in% allPeeps) ){
timesMatA3$thing <- rep(0,nrow(timesMatA3))
names(timesMatA3)[names(timesMatA3) == "thing"] <- colnames(timesMatA3)[i]
}
}
for(i in 1:(length(colnames(timesMatA3)) - 1) ){
if( !(colnames(timesMatA3)[i] %in% allPeeps) ){
timesMatA3$thing <- rep(0,nrow(timesMatA3))
names(timesMatA3)[names(timesMatA3) == "thing"] <- colnames(timesMatA3)[i]
}
}
timesMatA3
for(i in 1:(length(colnames(timesMatB3)) - 1) ){
if( !(colnames(timesMatB3)[i] %in% allPeeps) ){
timesMatB3$thing <- rep(0,nrow(timesMatB3))
names(timesMatB3)[names(timesMatB3) == "thing"] <- colnames(timesMatB3)[i]
}
}
timesMatB3
colnames(timesMatB3)
length(colnames(timesMatB3)) - 1
allPeeps
i <- 4
!(allPeeps[i] %in% colnames(timesMatB3))
timesMatB3$thing <- rep(0,nrow(timesMatB3))
timesMatB3
names(timesMatB3)[names(timesMatB3) == "thing"] <- allPeeps[i]
timesMatB3
for(i in 1:(length(colnames(timesMatB3)) - 1) ){
if( !(allPeeps[i] %in% colnames(timesMatB3)) ){
timesMatB3$thing <- rep(0,nrow(timesMatB3))
names(timesMatB3)[names(timesMatB3) == "thing"] <- allPeeps[i]
}
}
timesMatB3
allPeeps
for(i in 1:(length(allPeeps) - 1) ){
if( !(allPeeps[i] %in% colnames(timesMatB3)) ){
timesMatB3$thing <- rep(0,nrow(timesMatB3))
names(timesMatB3)[names(timesMatB3) == "thing"] <- allPeeps[i]
}
}
timesMatB3
for(i in 1:length(allPeeps) ){
if( !(allPeeps[i] %in% colnames(timesMatB3)) ){
timesMatB3$thing <- rep(0,nrow(timesMatB3))
names(timesMatB3)[names(timesMatB3) == "thing"] <- allPeeps[i]
}
}
timesMatB3
timesMatB3 <- timesMatB3[,allPeeps]
timesMatB3
timesMatA <- as.data.frame.matrix(table(times2$digiEndTimeAsDate2,times2$digiFirst))
timesMatA2 <- cbind(timesMatA,rowSums(timesMatA))
timesMatA3 <- rbind(timesMatA2,colSums(timesMatA2))
rownames(timesMatA3)[dim(timesMatA3)[1]] <- ""
colnames(timesMatA3)[dim(timesMatA3)[2]] <- "Total"
timesMatB <- as.data.frame.matrix(table(times2$digiEndTimeAsDate2,times2$PartnerFirst))
timesMatB2 <- cbind(timesMatB,rowSums(timesMatB))
timesMatB3 <- rbind(timesMatB2,colSums(timesMatB2))
rownames(timesMatB3)[dim(timesMatB3)[1]] <- ""
colnames(timesMatB3)[dim(timesMatB3)[2]] <- "Total"
timesMatA3
timesMatB3
#   ---- Dimensionality may vary between A3 and B3.  Check for this, and correct
#   ---- if necessary.
allPeeps <- unique(sort(c(colnames(timesMatA3),colnames(timesMatB3))))
allPeeps <- allPeeps[allPeeps != "Total"]
for(i in 1:length(allPeeps) ){
if( !(allPeeps[i] %in% colnames(timesMatA3)) ){
timesMatA3$thing <- rep(0,nrow(timesMatA3))
names(timesMatA3)[names(timesMatA3) == "thing"] <- allPeeps[i]
}
}
timesMatA3 <- timesMatA3[,c(allPeeps,"Total")]
for(i in 1:length(allPeeps) ){
if( !(allPeeps[i] %in% colnames(timesMatB3)) ){
timesMatB3$thing <- rep(0,nrow(timesMatB3))
names(timesMatB3)[names(timesMatB3) == "thing"] <- allPeeps[i]
}
}
timesMatB3 <- timesMatB3[,c(allPeeps,"Total")]
timesMatA3
timesMatB3
imesMatA3 + timesMatB3
timesMatA3 + timesMatB3
detach("package:pDog", unload=TRUE)
install.packages("L:/BTPD_2016/Analysis/pDog_0.8.4.6.zip", repos = NULL, type = "win.binary")
require(pDog)
userSummary()
userSummary(summary="Double")
getSkippers()
checkDoubles()
install.packages("L:/BTPD_2016/pDog Package/Pre-release Version/pDog_0.8.4.6.zip", repos = NULL, type = "win.binary")
require(pDog)
