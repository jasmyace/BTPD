#   ---- Given the list of towns, paste together into one nice shapefile.
allShps <- NULL
first <- 0
triggered <- 0
for(i in 1:nShps){
if( class(townShps[[i]]) == "SpatialPolygonsDataFrame" ){
nR <- length(slot(townShps[[i]],"polygons"));
if(triggered == 0){
first <- 1
}
if(first == 1){                                                                                                                                                                               # for 1st shp file, do this
uidR          <- 1;                                                                                                                                                               # make a unique id
allShps       <- spChFIDs(townShps[[i]], as.character(uidR:(uidR + nR - 1)));                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR;
triggered     <- 1
first         <- 0
} else {                                                                                                                                                                                  # for other than 1st shp file, do this
townShps[[i]] <- spChFIDs(townShps[[i]], as.character(uidR:(uidR + nR - 1)));                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR;                                                                                                                                                       # make unique id for all polys
allShps       <- spRbind(allShps,townShps[[i]]);                                                                                                                                   # union ith shp file with all previous ones
}
}
}
nTowns <- nrow(allShps)
#   ---- Check for loop-the-loops, etc.
gValid <- gIsValid(allShps,byid=TRUE)
if( sum(gValid) != nTowns ){
warning("Check gValid. Probably at least one town with remaining sliver.")
}
grid <- readOGR("//lar-file-srv/Data/BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_CO_Ranked","BTPD_Grid_CO_Ranked",verbose=FALSE)
#   ---- Check for towns that tangent a grid-cell border.
#   gg <- gIntersection(allShps,grid,byid=TRUE)
#   if( !(class(gg) == "SpatialPolygons") ){
#     warning("Intersection of towns with the grid found something other than SpatialPolygons.")
#   }
#   ---- Make sure towns don't overlap one another.
gInts <- gIntersects(allShps,allShps,byid=TRUE)
nTowns <- nrow(allShps)
if( sum(gInts) != nTowns ){
warning("Probable self-town intersection.")
}
#   ---- Check for towns numbered zero.
theZeros <- theTowns[theTowns$Town_ID == 0 & !is.na(theTowns$Town_ID),]
if( nrow(theZeros) != 0 ){
warning("Town_IDs of zeros observed.")
}
#   ---- Check for sequentially numbered towns.
theReals <- theTowns[!is.na(theTowns$Town_ID),]
theReals <- theReals[order(theReals$Grid_ID,theReals$Town_ID),]
theReals$checkRank <- unlist(tapply(theReals$Town_ID,factor(theReals$Grid_ID),function(x) seq(1,length(x),1)))
misNumbered <- theReals[theReals$Town_ID != theReals$checkRank,]
if( nrow(misNumbered) > 0 ){
warning("Town_IDs appear misnumbered.")
}
#   ---- Store for safekeeping.
#hold <- allShps
#allShps <- hold
#   ---- Bring in information on towns.
allShps@data$ID <- sapply(allShps@polygons,function(x) slot(x,"ID"))
allShps@data$R_ID <- seq(1,nrow(allShps@data),1)
allShps@data$AreaM2 <- gArea(allShps,byid=TRUE)
allShps@data$AreaAcres <- gArea(allShps,byid=TRUE) * 0.000247105
allShps@data$PerimM <- gLength(allShps,byid=TRUE)
#   ---- Determine the number of holes per town.
nTowns <- dim(allShps)[1]
indTowns <- vector("list",nTowns)
holes <- matrix(NA,nTowns,ncol=2,nrow=nTowns)
for(i in 1:nTowns){
indTowns[[i]] <- SpatialPolygons(list(allShps@polygons[[i]]))
holes[i,1] <- indTowns[[i]]@polygons[[1]]@ID
holes[i,2] <- sum(sapply(indTowns[[i]]@polygons[[1]]@Polygons,function(x) slot(x,"hole")))
}
holes <- data.frame(ID=holes[,1],nHoles=holes[,2],stringsAsFactors=FALSE)
allShps@data <- merge(allShps@data,holes,by=c('ID'),all.x=TRUE,all.y=TRUE)
allShps@data <- allShps@data[order(allShps@data$R_ID),]
allShps@data$CFactor <- ifelse(allShps@data$nHoles == 0,(allShps@data$PerimM)^2 / 4 / pi / allShps@data$AreaM2,NA)
allShps@data <- merge(allShps@data,tblRanks[,c('Grid_ID','sampleID')],by=c('Grid_ID'),all.x=TRUE)
allShps@data <- allShps@data[order(allShps@data$R_ID),]
towns <- data.frame(nTowns=tapply(allShps@data$Town_ID,factor(allShps@data$Grid_ID),function(x) length(x)))
towns$Grid_ID <- rownames(towns)
rownames(towns) <- NULL
class(towns)
class(towns$nTowns)
head(towns)
towns$nTowns <- as.numeric(towns$nTowns)
class(towns$nTowns)
class(towns$Grid_ID)
makeBigShape <- function(){
#   ---- Define useful projections.
projAEAc <- '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0'
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
#   ---- Get users.
tblNames <- checkUser(userID=100)
#   ---- Get sampling.
tblRanks <- getRankStatus()
tblRanks <- tblRanks[order(tblRanks$sampleID),]
done <- assign[assign$doneStatus == 1,]
done$digiEndTime <- as.POSIXct(done$digiEndTime,tz="America/Denver")
done$digiStartTime <- as.POSIXct(done$digiStartTime,tz="America/Denver")
done <- merge(done[,c('Grid_ID','digiPartner','doneStatus','digiDouble','digiUserID','digiStartTime','digiEndTime')],tblFolders[,c('Grid_ID','Range')],by=c('Grid_ID'),all.x=TRUE)
done <- merge(done,tblNames[,c('userID','FirstName')],by.x=c('digiUserID'),by.y=c('userID'),all.x=TRUE)
done <- merge(done,tblRanks[,c('Grid_ID','sampleID')],by=c('Grid_ID'),all.x=TRUE)
done <- done[order(done$sampleID),]
done$time <- done$digiEndTime - done$digiStartTime
#   ---- Get the shapefiles that should be done.
done$folder <- paste0('//lar-file-srv/Data/BTPD_2016/Digitizing/',done$Range,'/',done$Grid_ID)
#   ---- Need to see if we have shapefiles with no features. This happens often.
checkShp <- function(folder,shp){
if(is.null(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message)){
shp2 <- tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)
} else if(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message == "no features found" ){
shp2 <- "no features found"
}
}
#   ---- Assemble all the towns in all cells digitized up to this point.
nShps <- nrow(done)
townShps <- vector('list',nShps)
theCells <- vector('list',nShps)
theTowns <- NULL
for(i in 1:nShps){
townShps[[i]] <- checkShp(done[i,]$folder,paste0('p',done[i,]$FirstName,'_Towns_',done[i,]$Grid_ID))
theCells[[i]] <- readOGR(done[i,]$folder,paste0('LocalGrid_',done[i,]$Grid_ID),verbose=FALSE)
if( class(townShps[[i]]) == "SpatialPolygonsDataFrame" ){
iTowns <- townShps[[i]]@data
townShps[[i]]@data$Grid_ID <- done[i,]$Grid_ID
} else {
iTowns <- data.frame(Town_ID=NA,Grid_ID=NA)
}
iTowns$Grid_ID <- done[i,]$Grid_ID
theTowns <- rbind(theTowns,iTowns)
#   ---- Convert the line shapefile we read in into a
#   ---- polygonal one -- necessary for g functions.
localGridp <- as(theCells[[i]],"SpatialPoints")
c1 <- localGridp@coords
P1 = Polygon(c1)
Ps1 = Polygons(list(P1), ID="a")
theCell = SpatialPolygons(list(Ps1))
theCell@proj4string <- CRS(projAEAc)
theCells[[i]] <- theCell
#   ---- Check for floaters.
if( class(townShps[[i]]) == "SpatialPolygonsDataFrame" ){
if( sum(gDisjoint(townShps[[i]],theCells[[i]],byid=TRUE)) != 0 ){
plot(theCells[[i]])
plot(townShps[[i]],add=TRUE)
x <- (theCells[[i]]@bbox[1,2] + theCells[[i]]@bbox[1,1] ) / 2
y <- (theCells[[i]]@bbox[2,2] + theCells[[i]]@bbox[2,1] ) / 2
text(x,y,paste0("Problem with cell ",done[i,]$Grid_ID,"."))
stop
}
}
}
#   ---- Given the list of towns, paste together into one nice shapefile.
allShps <- NULL
first <- 0
triggered <- 0
for(i in 1:nShps){
if( class(townShps[[i]]) == "SpatialPolygonsDataFrame" ){
nR <- length(slot(townShps[[i]],"polygons"));
if(triggered == 0){
first <- 1
}
if(first == 1){                                                                                                                                                                               # for 1st shp file, do this
uidR          <- 1;                                                                                                                                                               # make a unique id
allShps       <- spChFIDs(townShps[[i]], as.character(uidR:(uidR + nR - 1)));                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR;
triggered     <- 1
first         <- 0
} else {                                                                                                                                                                                  # for other than 1st shp file, do this
townShps[[i]] <- spChFIDs(townShps[[i]], as.character(uidR:(uidR + nR - 1)));                                                                                                    # make feature id of polygons unique
uidR          <- uidR + nR;                                                                                                                                                       # make unique id for all polys
allShps       <- spRbind(allShps,townShps[[i]]);                                                                                                                                   # union ith shp file with all previous ones
}
}
}
nTowns <- nrow(allShps)
#   ---- Check for loop-the-loops, etc.
gValid <- gIsValid(allShps,byid=TRUE)
if( sum(gValid) != nTowns ){
warning("Check gValid. Probably at least one town with remaining sliver.")
}
grid <- readOGR("//lar-file-srv/Data/BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_CO_Ranked","BTPD_Grid_CO_Ranked",verbose=FALSE)
#   ---- Check for towns that tangent a grid-cell border.
#   gg <- gIntersection(allShps,grid,byid=TRUE)
#   if( !(class(gg) == "SpatialPolygons") ){
#     warning("Intersection of towns with the grid found something other than SpatialPolygons.")
#   }
#   ---- Make sure towns don't overlap one another.
gInts <- gIntersects(allShps,allShps,byid=TRUE)
nTowns <- nrow(allShps)
if( sum(gInts) != nTowns ){
warning("Probable self-town intersection.")
}
#   ---- Check for towns numbered zero.
theZeros <- theTowns[theTowns$Town_ID == 0 & !is.na(theTowns$Town_ID),]
if( nrow(theZeros) != 0 ){
warning("Town_IDs of zeros observed.")
}
#   ---- Check for sequentially numbered towns.
theReals <- theTowns[!is.na(theTowns$Town_ID),]
theReals <- theReals[order(theReals$Grid_ID,theReals$Town_ID),]
theReals$checkRank <- unlist(tapply(theReals$Town_ID,factor(theReals$Grid_ID),function(x) seq(1,length(x),1)))
misNumbered <- theReals[theReals$Town_ID != theReals$checkRank,]
if( nrow(misNumbered) > 0 ){
warning("Town_IDs appear misnumbered.")
}
#   ---- Store for safekeeping.
#hold <- allShps
#allShps <- hold
#   ---- Bring in information on towns.
allShps@data$ID <- sapply(allShps@polygons,function(x) slot(x,"ID"))
allShps@data$R_ID <- seq(1,nrow(allShps@data),1)
allShps@data$AreaM2 <- gArea(allShps,byid=TRUE)
allShps@data$AreaAcres <- gArea(allShps,byid=TRUE) * 0.000247105
allShps@data$PerimM <- gLength(allShps,byid=TRUE)
#   ---- Determine the number of holes per town.
nTowns <- dim(allShps)[1]
indTowns <- vector("list",nTowns)
holes <- matrix(NA,nTowns,ncol=2,nrow=nTowns)
for(i in 1:nTowns){
indTowns[[i]] <- SpatialPolygons(list(allShps@polygons[[i]]))
holes[i,1] <- indTowns[[i]]@polygons[[1]]@ID
holes[i,2] <- sum(sapply(indTowns[[i]]@polygons[[1]]@Polygons,function(x) slot(x,"hole")))
}
holes <- data.frame(ID=holes[,1],nHoles=holes[,2],stringsAsFactors=FALSE)
allShps@data <- merge(allShps@data,holes,by=c('ID'),all.x=TRUE,all.y=TRUE)
allShps@data <- allShps@data[order(allShps@data$R_ID),]
allShps@data$CFactor <- ifelse(allShps@data$nHoles == 0,(allShps@data$PerimM)^2 / 4 / pi / allShps@data$AreaM2,NA)
allShps@data <- merge(allShps@data,tblRanks[,c('Grid_ID','sampleID')],by=c('Grid_ID'),all.x=TRUE)
allShps@data <- allShps@data[order(allShps@data$R_ID),]
towns <- data.frame(nTowns=tapply(allShps@data$Town_ID,factor(allShps@data$Grid_ID),function(x) length(x)))
towns$Grid_ID <- rownames(towns)
rownames(towns) <- NULL
towns$nTowns <- as.numeric(towns$nTowns)
allShps@data <- merge(allShps@data,towns,by=c('Grid_ID'),all.x=TRUE)
allShps@data <- allShps@data[order(allShps@data$R_ID),]
allShps@data <- merge(allShps@data,done[,c('Grid_ID','time','digiUserID','digiPartner')],by=c('Grid_ID'),all.x=TRUE)
allShps@data <- merge(allShps@data,tblNames[,c('userID','FirstName')],by.x=c('digiUserID'),by.y=c('userID'),all.x=TRUE)
allShps@data <- allShps@data[order(allShps@data$R_ID),]
allShps@data$timeMin <- as.numeric(allShps@data$time)
allShps@data$time <- NULL
rownames(allShps@data) <- NULL
shps <- list(allShps,grid)
return(shps)
}
# write the shapefile of towns so far.
source("//lar-file-srv/Data/BTPD_2016/Analysis/pDog/R/getFolderStatus.R")
source("//lar-file-srv/Data/BTPD_2016/Analysis/pDog/R/getCellStatus.R")
source("//lar-file-srv/Data/BTPD_2016/Analysis/pDog/R/checkUser.R")
source("//lar-file-srv/Data/BTPD_2016/Analysis/pDog/R/getRankStatus.R")
shps <- makeBigShape()
writeOGR(shps[[1]],"C:/Users/jmitchell/Desktop/COTemp","townsSoFar",overwrite_layer=TRUE,driver="ESRI Shapefile")
head(shps[[1]]@data)
getStatus(100)
state <- 'CO'
alpha <- 0.10
alpha <- 0.10
state <- 'CO'
gridLines <- as(readOGR("lar-file-srv//BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_",state,"_Ranked","BTPD_Grid_",state,"_Ranked"),"SpatialLinesDataFrame")
plot(CO)
#   ---- Read in required packages.
require(rgeos)
require(rgdal)
require(raster)
require(maptools)
#   ---- Make a big town shapefile.
source("//lar-file-srv/Data/BTPD_2016/Analysis/pDog/R/getFolderStatus.R")
source("//lar-file-srv/Data/BTPD_2016/Analysis/pDog/R/getCellStatus.R")
source("//lar-file-srv/Data/BTPD_2016/Analysis/pDog/R/checkUser.R")
source("//lar-file-srv/Data/BTPD_2016/Analysis/pDog/R/getRankStatus.R")
source("//lar-file-srv/Data/BTPD_2016/Analysis/Overnights/makeBigShape.R")
shps <- makeBigShape()
CO <- shps[[1]]
plot(CO)
recoShps <- CO
gridPath <- paste0("lar-file-srv//BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_",state,"_Ranked")
grid <- paste0("BTPD_Grid_",state,"_Ranked")
head(recoShps@data)
shpTowns <- recoShps[substr(recoShps@data$Grid_ID,1,2) == state,]
dim(recoShps)
dim(shpTowns)
CO@data[CO@data$AreaAcres > 1000,]
(duplicated(shpTowns@data[,c("Grid_ID","Town_ID")]))
#   ---- Get N of cells.
uniqueCells <- dim(gridLines@data)[1]
gridLines <- as(readOGR(gridPath,grid),"SpatialLinesDataFrame")
shpTowns <- recoShps[substr(recoShps@data$Grid_ID,1,2) == state,]
gridPath <- paste0("lar-file-srv//BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_",state,"_Ranked")
grid <- paste0("BTPD_Grid_",state,"_Ranked")
gridLines <- as(readOGR(gridPath,grid),"SpatialLinesDataFrame")
shpTowns <- recoShps[substr(recoShps@data$Grid_ID,1,2) == state,]
gridPath <- paste0("lar-file-srv/Data/BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_",state,"_Ranked")
grid <- paste0("BTPD_Grid_",state,"_Ranked")
gridLines <- as(readOGR(gridPath,grid),"SpatialLinesDataFrame")
shpTowns <- recoShps[substr(recoShps@data$Grid_ID,1,2) == state,]
gridPath
readOGR(gridPath,grid)
help(readOGR)
grid
gridPath <- paste0("//lar-file-srv/Data/BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_",state,"_Ranked")
grid <- paste0("BTPD_Grid_",state,"_Ranked")
gridLines <- as(readOGR(gridPath,grid),"SpatialLinesDataFrame")
shpTowns <- recoShps[substr(recoShps@data$Grid_ID,1,2) == state,]
#   ---- Get N of cells.
uniqueCells <- dim(gridLines@data)[1]
#   ---- Make lists of Lines objects, each made of one line, of all
#   ---- transects in that particular direction.
w <- vector("list", uniqueCells)
n <- vector("list", uniqueCells)
e <- vector("list", uniqueCells)
s <- vector("list", uniqueCells)
for(j in 1:uniqueCells){
w[[j]] <- Lines(list(Line(gridLines@lines[[j]]@Lines[[1]]@coords[1:2,])), as.character(j))
n[[j]] <- Lines(list(Line(gridLines@lines[[j]]@Lines[[1]]@coords[2:3,])), as.character(j))
e[[j]] <- Lines(list(Line(gridLines@lines[[j]]@Lines[[1]]@coords[3:4,])), as.character(j))
s[[j]] <- Lines(list(Line(gridLines@lines[[j]]@Lines[[1]]@coords[4:5,])), as.character(j))
}
#   ---- Make a helpful vectors and objects.
NHatAll <- SHatAll <- NULL
dir <- c('w','n','e','s')
Sigma.N <- rep(NA,4)
Sigma.S <- rep(NA,4)
#   ---- Make bootstrapping objects.
bsData <- matrix(NA,nrow=nrow(shpTowns),ncol=4)
bsArray <- array(NA,dim=c(nrow(bsData),ncol=Bn,4))
NSampleArray <- array(NA,dim=c(nrow(bsData),ncol=Bn,4))
SSampleArray <- array(NA,dim=c(nrow(bsData),ncol=Bn,4))
NSamplej <- matrix(NA,nrow=Bn,ncol=4)
SSamplej <- matrix(NA,nrow=Bn,ncol=4)
SampleIj <- matrix(NA,nrow=Bn,ncol=4)
Bn <- 500
#   ---- Make bootstrapping objects.
bsData <- matrix(NA,nrow=nrow(shpTowns),ncol=4)
bsArray <- array(NA,dim=c(nrow(bsData),ncol=Bn,4))
NSampleArray <- array(NA,dim=c(nrow(bsData),ncol=Bn,4))
SSampleArray <- array(NA,dim=c(nrow(bsData),ncol=Bn,4))
NSamplej <- matrix(NA,nrow=Bn,ncol=4)
SSamplej <- matrix(NA,nrow=Bn,ncol=4)
SampleIj <- matrix(NA,nrow=Bn,ncol=4)
g <- 1
if(g == 1){the.list <- w}
if(g == 2){the.list <- n}
if(g == 3){the.list <- e}
if(g == 4){the.list <- s}
SL <- as(SpatialLines(the.list,proj4string=CRS(projAEA)),"SpatialLinesDataFrame")
SL@data <- data.frame(sapply(slot(SL, "lines"), function(k) slot(k, "ID")))
colnames(SL@data) <- 'Trans_ID'
#   ---- Define useful projections.
projAEAc  <- '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0'
if(g == 1){the.list <- w}
if(g == 2){the.list <- n}
if(g == 3){the.list <- e}
if(g == 4){the.list <- s}
SL <- as(SpatialLines(the.list,proj4string=CRS(projAEAc)),"SpatialLinesDataFrame")
SL@data <- data.frame(sapply(slot(SL, "lines"), function(k) slot(k, "ID")))
colnames(SL@data) <- 'Trans_ID'
class(SL)
head(SL@data)
tail(SL@data)
#   ---- Count the number of total crossings, per polygon / town.
#   ---- http://r-sig-geo.2731867.n2.nabble.com/split-divide-SpatialLines-sp-into-n-segments-td7583234.html
rownames <- rownames(shpTowns@data)
IntersectCounts <- rep(NA,length(rownames))
for(h in 1:length(rownames)){
Sl = as(shpTowns[rownames(shpTowns@data) == rownames[h],],"SpatialLines")#SpatialLines(list(Lines(list(Line(cbind(c(1,2,3),c(3,2,2)))),ID="a")))
cSl <- coordinates(Sl)
cSl
in_nrows <- lapply(cSl, function(x) sapply(x, nrow))
outn <- sapply(in_nrows, function(y) sum(y-1))
res <- vector(mode="list", length=outn)
i <- 1
for (j in seq(along=cSl)) {
for (k in seq(along=cSl[[j]])) {
for (l in 1:(nrow(cSl[[j]][[k]])-1)) {
res[[i]] <- cSl[[j]][[k]][l:(l+1),]
i <- i + 1
}
}
}
res1 <- vector(mode="list", length=outn)
for (i in seq(along=res))
res1[[i]] <- Lines(list(Line(res[[i]])), as.character(i))
outSL <- SpatialLines(res1)
outSL@proj4string <- CRS(projAEA)
IntersectCounts[h] <- sum(gIntersects(outSL,SL,byid=TRUE))
}
#   ---- Count the number of total crossings, per polygon / town.
#   ---- http://r-sig-geo.2731867.n2.nabble.com/split-divide-SpatialLines-sp-into-n-segments-td7583234.html
rownames <- rownames(shpTowns@data)
IntersectCounts <- rep(NA,length(rownames))
for(h in 1:length(rownames)){
Sl = as(shpTowns[rownames(shpTowns@data) == rownames[h],],"SpatialLines")#SpatialLines(list(Lines(list(Line(cbind(c(1,2,3),c(3,2,2)))),ID="a")))
cSl <- coordinates(Sl)
cSl
in_nrows <- lapply(cSl, function(x) sapply(x, nrow))
outn <- sapply(in_nrows, function(y) sum(y-1))
res <- vector(mode="list", length=outn)
i <- 1
for (j in seq(along=cSl)) {
for (k in seq(along=cSl[[j]])) {
for (l in 1:(nrow(cSl[[j]][[k]])-1)) {
res[[i]] <- cSl[[j]][[k]][l:(l+1),]
i <- i + 1
}
}
}
res1 <- vector(mode="list", length=outn)
for (i in seq(along=res))
res1[[i]] <- Lines(list(Line(res[[i]])), as.character(i))
outSL <- SpatialLines(res1)
outSL@proj4string <- CRS(projAEAc)
IntersectCounts[h] <- sum(gIntersects(outSL,SL,byid=TRUE))
}
names(IntersectCounts) <- rownames
head(IntersectCounts)
length(IntersectCounts)
IntersectCounts <- IntersectCounts[IntersectCounts > 0]
contains <- NA
segsContain <- gContains(shpTowns,SL,byid=TRUE)
for(h in 1:length(rownames)){
segsContain.h <- segsContain[,h]
if(sum(segsContain.h) > 0){
contains <- names(segsContain.h[segsContain.h==TRUE])
}
}
contains
length(rownames)
theIntsClean <- theInts[!(rownames(theInts) %in% contains),]
theInts <- gIntersects(shpTowns,SL,byid=TRUE)
theIntsClean <- theInts[!(rownames(theInts) %in% contains),]
theIntsClean
sum(theIntsClean)
theInts <- gIntersects(shpTowns,SL,byid=TRUE)
theIntsClean <- theInts[!(rownames(theInts) %in% contains),]     # throw out 1 contains -- we can do this, becasue if its contained in one town, it CANNOT possibly be in any others.
if(class(theIntsClean) == "logical"){  # there's only 1 town.  (could also only be one transect i guess...)
Ind <- sum(theIntsClean) > 0                                                                                         # ID intersections
Intersects <- sum(theIntsClean)[Ind]                                                                                 # count intersections
M <- shpTowns@data$R_ID    # M needs the TOWN id, not the segment id
} else {
Ind <- colSums(theIntsClean) > 0                                                                                     # ID intersections
Intersects <- colSums(theIntsClean)[Ind]                                                                             # count intersections
M <- names(Intersects)                                                                                               # get names of intersected towns (RID_R)
}
M
theIntsClean
class(theIntsClean)
M
#   ---- Get the town + one-direction transect intersections.  We exclude transects that are
#   ---- contained entirely within a town.  These transects intersect towns, in the
#   ---- gIntersects sense of intersect, but that doesn't not mean that the perimeter of the
#   ---- town crosses a transect.
theInts <- gIntersects(shpTowns,SL,byid=TRUE)
theIntsClean <- theInts[!(rownames(theInts) %in% contains),]
#   ---- Check if there's only one town -- results lead to a vector or matrix, and so much
#   ---- be set up to handle each.
if(class(theIntsClean) == "logical"){
#   ---- Identify and count the intersections.
Ind <- sum(theIntsClean) > 0
Intersects <- sum(theIntsClean)[Ind]
M <- shpTowns@data$R_ID    # M needs the TOWN id, not the segment id
} else {
#   ---- Identify and count the intersections.
Ind <- colSums(theIntsClean) > 0
Intersects <- colSums(theIntsClean)[Ind]
M <- names(Intersects)                                                                                               # get names of intersected towns (RID_R)
}
length(theInts)
length(theIntsClean)
class(theInts)
head(theInts)
if(state %in% c('1k','5k')){
#       getit <- data.frame(State=as.character(droplevels(shpTowns$State.x)))
#       getit$R_ID <- seq(1,nrow(getit),1)
#       getit2 <- merge(getit,samps,by=('State'),all.x=TRUE)
#       getit2 <- getit2[order(getit2$R_ID),]
#       getit2$R_ID <- NULL
#       getit2$factor <- getit2$Grid_N / getit2$Grid_Sampled_D
#       uniqueCells <- 132754
} else {
getit <- data.frame(State=rep(state,nrow(shpTowns)))
getit$R_ID <- seq(1,nrow(getit),1)
getit2 <- merge(getit,samps,by=('State'),all.x=TRUE)
getit2 <- getit2[order(getit2$R_ID),]
getit2$R_ID <- NULL
getit2$factor <- getit2$Grid_N / getit2$Grid_Sampled_D
uniqueCells <- samps[samps$State == state,]$Grid_N
}
head(shpTowns@data)
uniqueCells <- nrow(grid)
uniqueCells
nrow(grid)
class(grid)
nrow(gridLines)
getit <- data.frame(State=rep(state,nrow(shpTowns)))
getit
getit$R_ID <- seq(1,nrow(getit),1)
samps
require(devtools)
devtools::document()
userID
userID <- 100
lock <- grep("tblCellStatusLOCK",dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database"),fixed=TRUE)
if(length(lock) > 0){
stop("The function is currently locked;  try again in a minute.")
} else {
#   ---- Lock the table tblCellStatus so that two users cannot update
#   ---- it at the same time.
lockdf <- data.frame(userID=userID)
write.table(lockdf,"//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",row.names=FALSE)
}
