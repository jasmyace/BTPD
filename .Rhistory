class(done$digiStartTime)
done <- assign[assign$doneStatus == 1,c('Grid_ID','digiUserID','digiPartner','digiDouble','digiStartTime','digiEndTime')]
done$digiStartTime <- as.POSIXct(done$digiStartTime,tz="America/Denver")
done$digiEndTime <- as.POSIXct(done$digiEndTime,tz="America/Denver")
time <- done$digiEndTime - done$digiStartTime
head(time)
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
#   ---- Get users.
tblNames <- checkUser(userID=100)
#   ---- Get sampling.
tblRanks <- getRankStatus()
tblRanks <- tblRanks[order(tblRanks$sampleID),]
done <- assign[assign$doneStatus == 1,c('Grid_ID','digiUserID','digiPartner','digiDouble','digiStartTime','digiEndTime')]
done$digiStartTime <- as.POSIXct(done$digiStartTime,tz="America/Denver")
done$digiEndTime <- as.POSIXct(done$digiEndTime,tz="America/Denver")
done$time <- done$digiEndTime - done$digiStartTime
head(done)
hist(done)
hist(done$time)
hist(as.numeric(done$time))
done
hist(as.numeric(done[done$digiDouble == 0,]$time))
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
#   ---- Get users.
tblNames <- checkUser(userID=100)
#   ---- Get sampling.
tblRanks <- getRankStatus()
tblRanks <- tblRanks[order(tblRanks$sampleID),]
done <- assign[assign$doneStatus == 1,c('Grid_ID','digiUserID','digiPartner','digiDouble','digiStartTime','digiEndTime')]
done$digiStartTime <- as.POSIXct(done$digiStartTime,tz="America/Denver")
done$digiEndTime <- as.POSIXct(done$digiEndTime,tz="America/Denver")
done$time <- done$digiEndTime - done$digiStartTime
towns <- data.frame(nTowns=tapply(CO@data$Town_ID,factor(CO@data$Grid_ID),function(x) length(x)))
towns$Grid_ID <- rownames(towns)
rownames(towns) <- NULL
done <- merge(done,towns,by=c('Grid_ID'),all.x=TRUE)
head(done)
done$nTowns[is.na(done$nTowns)] <- 0
head(done)
hist(done$nTowns)
plot(done[done$digiDouble == 0,]$time,done[done$digiDouble == 0,]$nTowns)
plot(done[done$digiDouble == 0,]$nTowns,done[done$digiDouble == 0,]$time)
avgTowns <- mean(done$nTowns)
avgTowns
median(done$nTowns)
tapply(as.numeric(done$time),factor(done$nTowns),function(x) average(x))
tapply(as.numeric(done$time),factor(done$nTowns),function(x) mean(x))
done[done$nTowns == 0,]
avgTowns <- mean(done$nTowns)
avgTowns
tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x))
singly <- done[done$digiDouble == 0,]
tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x))
avgMinTown <- tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x))
avgMinTown <- data.frame(avgMin=tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x)))
avgMinTown$nTowns <- rownames(avgMinTown)
rownames(avgMinTown) <- NULL
avgMinTown
plot(avgMinTown$nTowns,avgMinTown$avgMin)
singly
plot(factor(singly$nTowns),as.numeric(singly$time))
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
#   ---- Get users.
tblNames <- checkUser(userID=100)
#   ---- Get sampling.
tblRanks <- getRankStatus()
tblRanks <- tblRanks[order(tblRanks$sampleID),]
done <- assign[assign$doneStatus == 1,c('Grid_ID','digiUserID','digiPartner','digiDouble','digiStartTime','digiEndTime')]
done$digiStartTime <- as.POSIXct(done$digiStartTime,tz="America/Denver")
done$digiEndTime <- as.POSIXct(done$digiEndTime,tz="America/Denver")
done$time <- done$digiEndTime - done$digiStartTime
towns <- data.frame(nTowns=tapply(CO@data$Town_ID,factor(CO@data$Grid_ID),function(x) length(x)))
towns$Grid_ID <- rownames(towns)
rownames(towns) <- NULL
done <- merge(done,towns,by=c('Grid_ID'),all.x=TRUE)
done$nTowns[is.na(done$nTowns)] <- 0
singly <- done[done$digiDouble == 0,]
avgTowns <- mean(done$nTowns)
avgMinTown <- data.frame(avgMin=tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x)))
avgMinTown$nTowns <- rownames(avgMinTown)
rownames(avgMinTown) <- NULL
avgMinTown
#   ---- Calculate mean singly time.
avgTowns <- mean(singly$nTowns)
avgTowns
#   ---- Calculate time as a function of number of towns.
avgMinTown <- data.frame(avgMin=tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x)))
avgMinTown$nTowns <- rownames(avgMinTown)
rownames(avgMinTown) <- NULL
avgMinTown$prop <- avgMinTown$nTowns / sum(avgMinTown$nTowns)
class(avgMinTown$nTowns)
#   ---- Calculate time as a function of number of towns.
avgMinTown <- data.frame(avgMin=tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x)))
avgMinTown$nTowns <- as.numeric(rownames(avgMinTown))
rownames(avgMinTown) <- NULL
avgMinTown$prop <- avgMinTown$nTowns / sum(avgMinTown$nTowns)
avgMinTown
towns
avgMinTown
#   ---- Count the number of towns per cell.
towns <- data.frame(nTowns=tapply(CO@data$Town_ID,factor(CO@data$Grid_ID),function(x) length(x)))
towns$Grid_ID <- rownames(towns)
rownames(towns) <- NULL
towns
head(singly)
hist(singly$nTowns)
help(hist)
ugh <- hist(singly$nTowns)
ugh
dev.off()
hist(singly$nTowns)$counts
help(hist)
hist(singly$nTowns,plot=FALSE)$counts
hist(singly$nTowns,plot=FALSE)$breaks
hist(singly$nTowns,plot=FALSE,breaks=seq(1,max(singly$nTowns),1))$counts
hist(singly$nTowns,plot=FALSE,breaks=seq(1,max(singly$nTowns),1))$breaks
hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns),1))$counts
hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns),1))$breaks
singly[singly$nTowns == 1,]
hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns),1),right=FALSE)$counts
hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns),1),right=FALSE)$breaks
singly[singly$nTowns == 6,]
singly[singly$nTowns == 9,]
max(singly$nTowns)
hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$counts
hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$breaks
#   ---- make distribution of town counts.
counts=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$counts
nTowns=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$breaks
townDist <- data.frame(counts=counts,nTowns=nTowns[1:length(counts)])
townDist
merge(avgMinTown,townDist,by=c('nTowns'),all.x=TRUE,all.y=TRUE)
#   ---- Calculate time as a function of number of towns.
avgMinTown <- data.frame(avgMin=tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x)))
avgMinTown$nTowns <- as.numeric(rownames(avgMinTown))
rownames(avgMinTown) <- NULL
#   ---- make distribution of town counts.
counts=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$counts
nTowns=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$breaks
townDist <- data.frame(counts=counts,nTowns=nTowns[1:length(counts)])
townCounts <- merge(avgMinTown,townDist,by=c('nTowns'),all.x=TRUE,all.y=TRUE)
townCounts
sum(townCounts$counts)
dim(CO)
plot(CO)
CO@data
sum(townCounts$counts*townCounts$nTowns)
dim(CO)
townCounts <- merge(avgMinTown,townDist,by=c('nTowns'),all.x=TRUE,all.y=TRUE)
townCounts$prop <- townCounts$counts / sum(townCounts$counts*townCounts$nTowns)
townCounts
sum(counts)
nShps
#   ---- Define useful projections.
projAEAc <- '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0'
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
#   ---- Get users.
tblNames <- checkUser(userID=100)
#   ---- Get sampling.
tblRanks <- getRankStatus()
tblRanks <- tblRanks[order(tblRanks$sampleID),]
done <- assign[assign$doneStatus == 1,]
done <- merge(done[,c('Grid_ID','doneStatus','digiDouble','digiUserID')],tblFolders[,c('Grid_ID','Range')],by=c('Grid_ID'),all.x=TRUE)
done <- merge(done,tblNames[,c('userID','FirstName')],by.x=c('digiUserID'),by.y=c('userID'),all.x=TRUE)
done <- merge(done,tblRanks[,c('Grid_ID','sampleID')],by=c('Grid_ID'),all.x=TRUE)
done <- done[order(done$sampleID),]
#   ---- Get the shapefiles that should be done.
done$folder <- paste0('//lar-file-srv/Data/BTPD_2016/Digitizing/',done$Range,'/',done$Grid_ID)
#   ---- Need to see if we have shapefiles with no features. This happens often.
checkShp <- function(folder,shp){
if(is.null(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message)){
shp2 <- tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)
} else if(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message == "no features found" ){
shp2 <- "no features found"
}
}
#   ---- Assemble all the towns in all cells digitized up to this point.
nShps <- nrow(done)
nShps
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
#   ---- Get users.
tblNames <- checkUser(userID=100)
#   ---- Get sampling.
tblRanks <- getRankStatus()
tblRanks <- tblRanks[order(tblRanks$sampleID),]
#   ---- Calculate elapsed time spent while digitizing.
done <- assign[assign$doneStatus == 1,c('Grid_ID','digiUserID','digiPartner','digiDouble','digiStartTime','digiEndTime')]
done$digiStartTime <- as.POSIXct(done$digiStartTime,tz="America/Denver")
done$digiEndTime <- as.POSIXct(done$digiEndTime,tz="America/Denver")
done$time <- done$digiEndTime - done$digiStartTime
#   ---- Count the number of towns per cell.
towns <- data.frame(nTowns=tapply(CO@data$Town_ID,factor(CO@data$Grid_ID),function(x) length(x)))
towns$Grid_ID <- rownames(towns)
rownames(towns) <- NULL
#   ---- Put together times and town counts.
done <- merge(done,towns,by=c('Grid_ID'),all.x=TRUE)
done$nTowns[is.na(done$nTowns)] <- 0
#   ---- Focus on singly digitized.
singly <- done[done$digiDouble == 0,]
#   ---- Calculate mean singly number of towns.
avgTowns <- mean(singly$nTowns)
#   ---- Calculate time as a function of number of towns.
avgMinTown <- data.frame(avgMin=tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x)))
avgMinTown$nTowns <- as.numeric(rownames(avgMinTown))
rownames(avgMinTown) <- NULL
#   ---- make distribution of town counts.
counts=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$counts
nTowns=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$breaks
townDist <- data.frame(counts=counts,nTowns=nTowns[1:length(counts)])
townCounts <- merge(avgMinTown,townDist,by=c('nTowns'),all.x=TRUE,all.y=TRUE)
townCounts$prop <- townCounts$counts / sum(townCounts$counts*townCounts$nTowns)
townCounts
sum(townCounts$counts)
townCounts$prop <- townCounts$counts / sum(townCounts$counts)
townCounts
dim(assign)
dim(done)
nLeft <- nrow(assign) - nrow(done)
nLeft
townCounts$nLeft <- nLeft
townCounts
#   ---- Calculate proportion of cells having the town distribution.
townCounts <- merge(avgMinTown,townDist,by=c('nTowns'),all.x=TRUE,all.y=TRUE)
townCounts$prop <- townCounts$counts / sum(townCounts$counts)
#   ---- Find the remaining number of cells, and estimate time to completion.
nLeft <- nrow(assign) - nrow(done)
townCounts$propLeft <- nLeft*townCounts$prop
townCounts
sum(townCounts$propLeft)
townCounts$totMins <- townCounts$propLeft*townCounts$avgMin
townCounts
nLeft <- nrow(assign) - nrow(done)
townCounts$propLeft <- nLeft*townCounts$prop
townCounts$totMins <- townCounts$propLeft*townCounts$avgMin
townCounts$totMins[is.na(townCounts$totMins)] <- 0
townCounts
totHours <- sum(townCounts$totMins) / 60
totHours
avgTowns
mean(singly$time) * nLeft
m1TotMins <- mean(singly$time) * nLeft
m1TotHours <- m1TotMins / 60
m1TotHours
2188/6
364.6667/6
#   ---- Method 1:
m1TotMins <- mean(as.numeric(singly$time)) * nLeft
m1TotHours <- m1TotMins / 60
m1TotHours
sum(townCounts$totMins) / 60
getStatus("All")
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
#   ---- Get users.
tblNames <- checkUser(userID=100)
#   ---- Get sampling.
tblRanks <- getRankStatus()
tblRanks <- tblRanks[order(tblRanks$sampleID),]
#   ---- Calculate elapsed time spent while digitizing.
done <- assign[assign$doneStatus == 1,c('Grid_ID','digiUserID','digiPartner','digiDouble','digiStartTime','digiEndTime')]
done$digiStartTime <- as.POSIXct(done$digiStartTime,tz="America/Denver")
done$digiEndTime <- as.POSIXct(done$digiEndTime,tz="America/Denver")
done$time <- done$digiEndTime - done$digiStartTime
#   ---- Count the number of towns per cell.
towns <- data.frame(nTowns=tapply(CO@data$Town_ID,factor(CO@data$Grid_ID),function(x) length(x)))
towns$Grid_ID <- rownames(towns)
rownames(towns) <- NULL
#   ---- Put together times and town counts.
done <- merge(done,towns,by=c('Grid_ID'),all.x=TRUE)
done$nTowns[is.na(done$nTowns)] <- 0
#   ---- Focus on singly digitized.
singly <- done[done$digiDouble == 0,]
#   ---- Calculate mean singly number of towns.
avgTowns <- mean(singly$nTowns)
#   ---- Calculate time as a function of number of towns.
avgMinTown <- data.frame(avgMin=tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x)))
avgMinTown$nTowns <- as.numeric(rownames(avgMinTown))
rownames(avgMinTown) <- NULL
#   ---- Make distribution of town counts.
counts=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$counts
nTowns=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$breaks
townDist <- data.frame(counts=counts,nTowns=nTowns[1:length(counts)])
#   ---- Calculate proportion of cells having the town distribution.
townCounts <- merge(avgMinTown,townDist,by=c('nTowns'),all.x=TRUE,all.y=TRUE)
townCounts$prop <- townCounts$counts / sum(townCounts$counts)
#   ---- Find the remaining number of cells, and estimate time to completion.
nLeft <- nrow(assign) - nrow(done)
townCounts$propLeft <- nLeft*townCounts$prop
townCounts$totMins <- townCounts$propLeft*townCounts$avgMin
townCounts$totMins[is.na(townCounts$totMins)] <- 0
#   ---- Method 1:
m1TotMins <- mean(as.numeric(singly$time)) * nLeft
m1TotHours <- m1TotMins / 60
totHours <- sum(townCounts$totMins) / 60
plot(avgMinTown$nTowns,avgMinTown$avgMin)
dev.off()
plot(avgMinTown$nTowns,avgMinTown$avgMin)
plot(factor(singly$nTowns),as.numeric(singly$time))
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
#   ---- Get users.
tblNames <- checkUser(userID=100)
#   ---- Get sampling.
tblRanks <- getRankStatus()
tblRanks <- tblRanks[order(tblRanks$sampleID),]
#   ---- Calculate elapsed time spent while digitizing.
done <- assign[assign$doneStatus == 1,c('Grid_ID','digiUserID','digiPartner','digiDouble','digiStartTime','digiEndTime')]
done$digiStartTime <- as.POSIXct(done$digiStartTime,tz="America/Denver")
done$digiEndTime <- as.POSIXct(done$digiEndTime,tz="America/Denver")
done$time <- done$digiEndTime - done$digiStartTime
#   ---- Count the number of towns per cell.
towns <- data.frame(nTowns=tapply(CO@data$Town_ID,factor(CO@data$Grid_ID),function(x) length(x)))
towns$Grid_ID <- rownames(towns)
rownames(towns) <- NULL
#   ---- Put together times and town counts.
done <- merge(done,towns,by=c('Grid_ID'),all.x=TRUE)
done$nTowns[is.na(done$nTowns)] <- 0
#   ---- Focus on singly digitized.
singly <- done[done$digiDouble == 0,]
#   ---- Calculate mean singly number of towns.
avgTowns <- mean(singly$nTowns)
#   ---- Calculate time as a function of number of towns.
avgMinTown <- data.frame(avgMin=tapply(as.numeric(singly$time),factor(singly$nTowns),function(x) mean(x)))
avgMinTown$nTowns <- as.numeric(rownames(avgMinTown))
rownames(avgMinTown) <- NULL
#   ---- Make distribution of town counts.
counts=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$counts
nTowns=hist(singly$nTowns,plot=FALSE,breaks=seq(0,max(singly$nTowns) + 1,1),right=FALSE)$breaks
townDist <- data.frame(counts=counts,nTowns=nTowns[1:length(counts)])
#   ---- Calculate proportion of cells having the town distribution.
townCounts <- merge(avgMinTown,townDist,by=c('nTowns'),all.x=TRUE,all.y=TRUE)
townCounts$prop <- townCounts$counts / sum(townCounts$counts)
#   ---- Find the remaining number of cells, and estimate time to completion.
nLeft <- nrow(assign) - nrow(done)
townCounts$propLeft <- nLeft*townCounts$prop
townCounts$totMins <- townCounts$propLeft*townCounts$avgMin
townCounts$totMins[is.na(townCounts$totMins)] <- 0
#   ---- Method 1:
m1TotMins <- mean(as.numeric(singly$time)) * nLeft
m1TotHours <- m1TotMins / 60
totHours <- sum(townCounts$totMins) / 60
plot(factor(singly$nTowns),as.numeric(singly$time))
getStatus(100)
getStatus("All")
checkCellValidity('sJason_Towns_CO116397')
checkCellValidity('sJason_Towns_CO116397')
getStatus(100)
getStatus("All")
getStatus("All")
proj3857  <- "+init=epsg:3857"   # used by esri online naip imagery.
Grid_ID <- unlist(strsplit(shp,"_",fixed=TRUE)[[1]])[3]
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
theRange <- tblFolders[tblFolders$Grid_ID == Grid_ID,]$Range
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
theRange <- tblFolders[tblFolders$Grid_ID == Grid_ID,]$Range
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
theRange <- tblFolders[tblFolders$Grid_ID == Grid_ID,]$Range
unlist(strsplit(shp,"_",fixed=TRUE)[[1]])[3]
shp <- "reconciling_Towns_CO116397"
unlist(strsplit(shp,"_",fixed=TRUE)[[1]])[3]
Grid_ID <- unlist(strsplit(shp,"_",fixed=TRUE)[[1]])[3]
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
theRange <- tblFolders[tblFolders$Grid_ID == Grid_ID,]$Range
#   ---- Now that we know the pieces, find the folder.
shpDir <- paste0("//LAR-FILE-SRV/Data/BTPD_2016/Digitizing/",theRange,"/",Grid_ID)
#   ---- If this is a reconciling cell, it could be a text file, instead of a
#   ---- shapefile, by design.  This happens when reconciliation leads to
#   ---- no towns digitized.  Check for this to prevent errors below.
if( length(dir(shpDir)[dir(shpDir) == paste0(shp,".txt")]) == 1){
stop("This Grid_ID's set of reconciled towns numbers zero.  No checks will be performed.  If correct, continue to step 9.\n")
}
length(dir(shpDir)[dir(shpDir) == paste0(shp,".txt")])
#   ---- Need to see if we have shapefiles with no features. This happens often.
checkShp <- function(folder,shp){
if(is.null(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message)){
shp2 <- tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)
} else if(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message == "no features found" ){
shp2 <- 'no features found'
}
}
#   ---- Get the shapefile to check.
shpfile <- checkShp(shpDir,shp)
localGrid <- readOGR(shpDir,paste0("LocalGrid_",Grid_ID),verbose=FALSE)
#   ---- If the shapefile has no features, there is nothing to check.
if( !(class(shpfile) == "SpatialPolygonsDataFrame") ){
warning("No digitized towns found.  Make sure this is correct.  If so, continue.\n")
}
class(shpfile) == "SpatialPolygonsDataFrame"
#   ---- Convert the line shapefile we read in into a
#   ---- polygonal one -- necessary for g functions.
localGridp <- as(localGrid,"SpatialPoints")
c1 <- localGridp@coords
P1 = Polygon(c1)
Ps1 = Polygons(list(P1), ID="a")
theCell = SpatialPolygons(list(Ps1))
theCell@proj4string <- shpfile@proj4string
grid <- readOGR("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_CO_Ranked","BTPD_Grid_CO_Ranked",verbose=FALSE)
grid <- as(grid,"SpatialLinesDataFrame")
gValid <- gIsValid(spTransform(shpfile,CRS(proj3857)),byid=TRUE)
sum(gValid) < length(gValid)
gInts <- gIntersects(shpfile,shpfile,byid=TRUE)
nTowns <- nrow(shpfile@data)
plot(shpfile)
plot(theCell,add=TRUE)
sum(gDisjoint(shpfile,theCells,byid=TRUE))
sum(gDisjoint(shpfile,theCell,byid=TRUE))
Grid_ID
stop("At least one town is disjointed from Grid_ID ",Grid_ID,".  Investigate.\n")
#   ---- Make sure towns don't overlap one another.
gInts <- gIntersects(shpfile,shpfile,byid=TRUE)
nTowns <- nrow(shpfile@data)
sum(gInts) != nTowns
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Town_ID),])
sum(df$Town_ID == 0) > 0
shp
shpfile@data
#   ---- Check for towns numbered zero.
if( substr(shp,1,5) == "Recon" ) {
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Recon_T_ID),])
} else {
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Town_ID),])
}
#   ---- Check for towns numbered zero.
if( substr(shp,1,5) == "recon" ) {
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Recon_T_ID),])
} else {
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Town_ID),])
}
df
#   ---- Check for towns numbered zero.
if( substr(shp,1,5) == "recon" ) {
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Recon_T_ID),])
#   ---- Remove the lock, if it exists.
if(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")){file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")}
stop("This Grid_ID's set of towns has at least one Town_ID labeled with a zero.  Investigate.\n")
} else {
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Town_ID),])
#   ---- Remove the lock, if it exists.
if(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")){file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")}
stop("This Grid_ID's set of towns has at least one Town_ID labeled with a zero.  Investigate.\n")
}
#   ---- Check for towns numbered zero.
if( substr(shp,1,5) == "recon" ) {
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Recon_T_ID),])
if( sum(df$Recon_T_ID == 0) > 0 ){
#   ---- Remove the lock, if it exists.
if(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")){file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")}
stop("This Grid_ID's set of towns has at least one Town_ID labeled with a zero.  Investigate.\n")
}
} else {
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Town_ID),])
if( sum(df$Town_ID == 0) > 0 ){
#   ---- Remove the lock, if it exists.
if(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")){file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")}
stop("This Grid_ID's set of towns has at least one Town_ID labeled with a zero.  Investigate.\n")
}
}
#   ---- Check for sequentially numbered towns.
if( substr(shp,1,5) == "recon" ){
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Recon_T_ID),])
df$seq <- seq(1,nTowns,1)
if(df[nTowns,]$Recon_T_ID != df[nTowns,]$seq){
#   ---- Remove the lock, if it exists.
if(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")){file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")}
stop("This Grid_ID's set of towns has poor Town_ID numbering.  Investigate variable Recon_T_ID.\n")
}
} else {
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Town_ID),])
df$seq <- seq(1,nTowns,1)
if(df[nTowns,]$Town_ID != df[nTowns,]$seq){
#   ---- Remove the lock, if it exists.
if(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")){file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")}
stop("This Grid_ID's set of towns has poor Town_ID numbering.  Investigate variable Town_ID.\n")
}
}
substr(shp,1,5) == "recon"
df <- data.frame(Town_ID=shpfile@data[order(shpfile@data$Recon_T_ID),])
df$seq <- seq(1,nTowns,1)
df
data.frame(Town_ID=shpfile@data[order(shpfile@data$Recon_T_ID),])
data.frame(Recon_T_ID=shpfile@data[order(shpfile@data$Recon_T_ID),])
data.frame(Recon_T_ID=shpfile@data[order(shpfile@data$Recon_T_ID),c('Recon_T_ID')])
df <- data.frame(Recon_T_ID=shpfile@data[order(shpfile@data$Recon_T_ID),c('Recon_T_ID')])
df$seq <- seq(1,nTowns,1)
df
df[nTowns,]$Recon_T_ID != df[nTowns,]$seq
df[nTowns,]$Recon_T_ID
df[nTowns,]$seq
df[nTowns,]$Recon_T_ID != df[nTowns,]$seq
