#         if(userID == read.table("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",stringsAsFactors=FALSE)[2,1]){
#           file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
#         }
#       }
#
#       message("Here's the original error message:\n")
#       message(cond)
#       message(report)
#       # Choose a return value in case of error
#       return(NA)
#     },
#     warning=function(cond){
#       #message("Here's the original warning message:")
#       message(cond)
#       if(substr(cond$message,1,5) == "Ring "){
#         message("\nThis Grid_ID's set of towns has at least one sliver.  Investigate via the coordinates provided.\n")
#       }
#       # Choose a return value in case of warning
#       return(NA)
#     }
#   )
}
pShpCCheck <- checkApply(pShpC)
#   ---- Check and see if there are errors that should be remedied via
#   ---- the town tool in Arc.
readCheckCellValidity <- function(Shp){
out <- tryCatch(
{
checkCellValidity(Shp,userID)
},
warning = function(cond){
return(1)
}
)
return(out)
}
#   ---- Apply the checking function, collecting any evidence of a warning.
checkApply <- function(shp){
if(class(get(paste0(substr(shp,1,1),'Shp'))) == "SpatialPolygonsDataFrame"){
lapply(shp,readCheckCellValidity)
} else {
cat(paste0("The check of ",shp," found no towns to check.  Be sure this is correct. If so, continue.\n"))
}
}
pShpCCheck <- checkApply(pShpC)
paste0("               setUpReconcile('",theNext,"',",userID,")\n\n")
paste0("               checkCellValidity('reconciling_Towns_",theNext,"',",userID,")\n\n")
theNext
userID
#   ---- Check for a lock on table tblCellStatus.csv
lock <- grep("tblCellStatusLOCK",dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database"),fixed=TRUE)
if(length(lock) > 0){
stop("The function is currently locked;  try again in a minute.")
} else {
#   ---- Lock the table tblCellStatus so that two users cannot update
#   ---- it at the same time.
lockdf <- data.frame(userID=userID)
write.table(lockdf,"//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",row.names=FALSE)
}
assign <- read.csv("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus.csv",as.is = TRUE)
if( assign[assign$Grid_ID == theNext,]$open == 1 | assign[assign$Grid_ID == theNext,]$doneStatus == 1 ){
#   ---- Remove the lock, if it exists, and the user calling the function placed it there.
if(invisible(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt"))){
if(userID == read.table("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",stringsAsFactors=FALSE)[2,1]){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
}
}
stop("It appears as if the Grid_ID of the cell you're attempting to check in hasn't been checked out, or is already complete.  Investigate.")
}
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
theRange <- tblFolders[tblFolders$Grid_ID == theNext,]$Range
folder <- paste0("//LAR-FILE-SRV/Data/BTPD_2016/Digitizing/",theRange,"/",theNext)
files <- dir(folder)
#   ---- Determine if this is a singly or doubly sampled cell.
ranks <- getRankStatus()
double <- 0
if( ranks[ranks$Grid_ID == theNext,]$dblSamp == 1){
double <- 1
}
if( double == 1 ){
#   ---- Double, so make sure there is an 's' and 'reconciling' shapefile.
sInd <- substr(files,1,1) == 's' &
substr(files,nchar(files) - 3,nchar(files)) == ".shp" &
grepl("Towns",files,fixed=TRUE)
sShpC <- substr(files[sInd],1,nchar(files[sInd]) - 4)
#   ---- Double, so make sure there is an 's' and 'reconciling' shapefile.
rInd <- (substr(files,1,11) == 'reconciling' &
( substr(files,nchar(files) - 3,nchar(files)) == ".shp" |
substr(files,nchar(files) - 3,nchar(files)) == ".txt" ) )
rShpC <- substr(files[rInd],1,nchar(files[rInd]) - 4)
if( is.na(rShpC) | is.na(sShpC) | is.null(sShpC) | is.null(rShpC) | length(sShpC) == 0 | length(rShpC) == 0 ){
#   ---- Remove the lock.
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
stop("The folder tied to the doubly sampled Grid_ID provided lacks the requisite 's' and 'reconciling' shapefiles.  Investigate.")
}
}
#   ---- Find the primary shapefiles.
pShp <- sShp <- NA
pInd <- substr(files,1,1) == 'p' &
substr(files,nchar(files) - 3,nchar(files)) == ".shp" &
grepl("Towns",files,fixed=TRUE)
pShpC <- substr(files[pInd],1,nchar(files[pInd]) - 4)
if( is.na(pShpC) | is.null(pShpC) | length(pShpC) == 0 ){
#   ---- Remove the lock.
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
stop("The folder tied to the doubly sampled Grid_ID provided lacks the requisite 'p' shapefile.  Investigate.\n")
}
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
theRange <- tblFolders[tblFolders$Grid_ID == theNext,]$Range
folder <- paste0("//LAR-FILE-SRV/Data/BTPD_2016/Digitizing/",theRange,"/",theNext)
files <- dir(folder)
#   ---- Determine if this is a singly or doubly sampled cell.
ranks <- getRankStatus()
double <- 0
if( ranks[ranks$Grid_ID == theNext,]$dblSamp == 1){
double <- 1
}
if( double == 1 ){
#   ---- Double, so make sure there is an 's' and 'reconciling' shapefile.
sInd <- substr(files,1,1) == 's' &
substr(files,nchar(files) - 3,nchar(files)) == ".shp" &
grepl("Towns",files,fixed=TRUE)
sShpC <- substr(files[sInd],1,nchar(files[sInd]) - 4)
#   ---- Double, so make sure there is an 's' and 'reconciling' shapefile.
rInd <- (substr(files,1,11) == 'reconciling' &
( substr(files,nchar(files) - 3,nchar(files)) == ".shp" |
substr(files,nchar(files) - 3,nchar(files)) == ".txt" ) )
rShpC <- substr(files[rInd],1,nchar(files[rInd]) - 4)
if( is.na(rShpC) | is.na(sShpC) | is.null(sShpC) | is.null(rShpC) | length(sShpC) == 0 | length(rShpC) == 0 ){
#   ---- Remove the lock, if it exists, and the user calling the function placed it there.
if(invisible(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt"))){
if(userID == read.table("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",stringsAsFactors=FALSE)[2,1]){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
}
}
stop("The folder tied to the doubly sampled Grid_ID provided lacks the requisite 's' and 'reconciling' shapefiles.  Investigate.")
}
}
#   ---- Find the primary shapefiles.
pShp <- sShp <- NA
pInd <- substr(files,1,1) == 'p' &
substr(files,nchar(files) - 3,nchar(files)) == ".shp" &
grepl("Towns",files,fixed=TRUE)
pShpC <- substr(files[pInd],1,nchar(files[pInd]) - 4)
if( is.na(pShpC) | is.null(pShpC) | length(pShpC) == 0 ){
#   ---- Remove the lock, if it exists, and the user calling the function placed it there.
if(invisible(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt"))){
if(userID == read.table("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",stringsAsFactors=FALSE)[2,1]){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
}
}
stop("The folder tied to the doubly sampled Grid_ID provided lacks the requisite 'p' shapefile.  Investigate.\n")
}
#   ---- Need to see if we have shapefiles with no features. This happens often.
checkShp <- function(folder,shp){
if(is.null(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message)){
shp2 <- tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)
} else if(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message == "no features found" ){
shp2 <- 'no features found'
}
}
#   ---- Read in shapefiles, allowing for no features found.
pShp <- checkShp(folder,pShpC)
if( double == 1){sShp <- checkShp(folder,sShpC)}
#   ---- Check and see if there are errors that should be remedied via
#   ---- the town tool in Arc.
readCheckCellValidity <- function(Shp){
out <- tryCatch(
{
checkCellValidity(Shp,userID)
},
warning = function(cond){
return(1)
}
)
return(out)
}
#   ---- Apply the checking function, collecting any evidence of a warning.
checkApply <- function(shp){
if(class(get(paste0(substr(shp,1,1),'Shp'))) == "SpatialPolygonsDataFrame"){
lapply(shp,readCheckCellValidity)
} else {
cat(paste0("The check of ",shp," found no towns to check.  Be sure this is correct. If so, continue.\n"))
}
}
pShpCCheck <- checkApply(pShpC)
if( double == 1){sShpCCheck <- checkApply(sShpC)}
#   ---- Update the tblCellStatus csv so that this cell is officially checked in.
#   ---- The real deal version.
head(assign)
as.POSIXlt(assign$buffEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver")
head(as.POSIXlt(assign$buffEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver"))
assign$digiEndTime <- as.POSIXlt(assign$digiEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver")
assign$buffEndTime <- as.POSIXlt(assign$buffEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver")
head(assign)
head(assign,100)
as.POSIXct(Sys.time(),format="%m/%d/%Y %H:%M",tz="America/Denver")
assign[assign$Grid_ID == "CO115329",]
assign <- read.csv("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus.csv",as.is = TRUE)
head(assign)
assign <- read.csv("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus.csv")
head(assign)
assign <- read.csv("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus.csv",as.is = TRUE)
assign$digiEndTime <- as.POSIXlt(assign$digiEndTime,format="%m/%d/%Y %H:%M:%S",tz="America/Denver")
head(assign)
assign$buffEndTime <- as.POSIXlt(assign$buffEndTime,format="%m/%d/%Y %H:%M:%s",tz="America/Denver")
head(assign)
assign <- read.csv("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus.csv",as.is = TRUE)
head(assign)
head(assign$digiEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver"))
head(assign$digiEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver")
head(as.POSIXlt(assign$digiEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver"))
strftime(as.POSIXlt(assign$digiEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver"),format="%m/%d/%Y %H:%M")
head(strftime(as.POSIXlt(assign$digiEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver"),format="%m/%d/%Y %H:%M"))
head(assign)
assign$buffEndTime <- strftime(as.POSIXlt(assign$buffEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver"),format="%m/%d/%Y %H:%M")
head(assign)
class(assign$buffEndTime)
assign$digiEndTime <- as.POSIXlt(as.POSIXlt(assign$digiEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver"),format="%m/%d/%Y %H:%M")
assign$buffEndTime <- as.POSIXlt(as.POSIXlt(assign$buffEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver"),format="%m/%d/%Y %H:%M")
head(assign)
assign$digiEndTime <- as.POSIXlt(assign$digiEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver")
assign$buffEndTime <- as.POSIXlt(assign$buffEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver")
head(assign)
class(assign$buffEndTime)
assign[assign$Grid_ID == theNext,]
#   ---- First, update the cell that was digitized.
assign[assign$Grid_ID == theNext,]$openStatus <- 1
assign[assign$Grid_ID == theNext,]$digiStatus <- 0
as.POSIXct(Sys.time(),format="%m/%d/%Y %H:%M",tz="America/Denver")
assign[assign$Grid_ID == theNext,]$digiEndTime <- as.POSIXct(Sys.time(),format="%m/%d/%Y %H:%M",tz="America/Denver")
assign[assign$Grid_ID == theNext,]$doneStatus <- 1
#   ---- Next, update the cells that were locked via buffering.
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffStatus <- 0
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffUserID <- NA
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffPartner <- NA
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffEndTime <- as.POSIXct(Sys.time(),tz="America/Denver",format="%m/%d/%Y %H:%M")
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffLockGrid_ID <- NA
assign[assign$Grid_ID == "CO115329",]
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]
#   ---- The running versions.
vList <- dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus")
version <- max(substr(vList,nchar(vList) - 9,nchar(vList) - 4))
newVersion <- sprintf("%06d",(as.numeric(version) + 1))
head(assign)
newVersion
write.csv(assign,paste0("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus/tblCellStatus",newVersion,".csv"),row.names=FALSE)
is.na(pShpC) | is.null(pShpC) | length(pShpC) == 0
#   ---- Check for a lock on table tblCellStatus.csv
lock <- grep("tblCellStatusLOCK",dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database"),fixed=TRUE)
if(length(lock) > 0){
stop("The function is currently locked;  try again in a minute.")
} else {
#   ---- Lock the table tblCellStatus so that two users cannot update
#   ---- it at the same time.
lockdf <- data.frame(userID=userID)
write.table(lockdf,"//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",row.names=FALSE)
}
#   ---- Check for a lock on table tblCellStatus.csv
lock <- grep("tblCellStatusLOCK",dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database"),fixed=TRUE)
if(length(lock) > 0){
stop("The function is currently locked;  try again in a minute.")
} else {
#   ---- Lock the table tblCellStatus so that two users cannot update
#   ---- it at the same time.
lockdf <- data.frame(userID=userID)
write.table(lockdf,"//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",row.names=FALSE)
}
#   ---- Apply the checking function, collecting any evidence of a warning.
checkApply <- function(shp){
if(class(get(paste0(substr(shp,1,1),'Shp'))) == "SpatialPolygonsDataFrame"){
lapply(shp,readCheckCellValidity)
#   ---- The function call to readCheckCellValidity gets rid of the lock.  Put it back for the
#   ---- function checkInCell.
#   ---- Check for a lock on table tblCellStatus.csv
lock <- grep("tblCellStatusLOCK",dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database"),fixed=TRUE)
if(length(lock) > 0){
stop("The function is currently locked;  try again in a minute.")
} else {
#   ---- Lock the table tblCellStatus so that two users cannot update
#   ---- it at the same time.
lockdf <- data.frame(userID=userID)
write.table(lockdf,"//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",row.names=FALSE)
}
} else {
cat(paste0("The check of ",shp," found no towns to check.  Be sure this is correct. If so, continue.\n"))
}
}
pShpCCheck <- checkApply(pShpC)
#   ---- Remove the lock, if it exists, and the user calling the function placed it there.
if(invisible(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt"))){
if(userID == read.table("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",stringsAsFactors=FALSE)[2,1]){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
}
}
cat(paste0("\nThe status of your new cell has successfully been updated in tblCellStatus.csv.\n"))
head(assign)
write.csv(assign,"//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus.csv",row.names=FALSE)
cat(paste0("Cell ",theNext," is now checked in.  Feel free to start digitizing another.\n"))
theNext <- "CO119106"
userID <- 100
#   ---- Check for a lock on table tblCellStatus.csv
lock <- grep("tblCellStatusLOCK",dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database"),fixed=TRUE)
if(length(lock) > 0){
stop("The function is currently locked;  try again in a minute.")
} else {
#   ---- Lock the table tblCellStatus so that two users cannot update
#   ---- it at the same time.
lockdf <- data.frame(userID=userID)
write.table(lockdf,"//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",row.names=FALSE)
}
assign <- read.csv("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus.csv",as.is = TRUE)
if( assign[assign$Grid_ID == theNext,]$open == 1 | assign[assign$Grid_ID == theNext,]$doneStatus == 1 ){
#   ---- Remove the lock, if it exists, and the user calling the function placed it there.
if(invisible(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt"))){
if(userID == read.table("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",stringsAsFactors=FALSE)[2,1]){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
}
}
stop("It appears as if the Grid_ID of the cell you're attempting to check in hasn't been checked out, or is already complete.  Investigate.")
}
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
theRange <- tblFolders[tblFolders$Grid_ID == theNext,]$Range
folder <- paste0("//LAR-FILE-SRV/Data/BTPD_2016/Digitizing/",theRange,"/",theNext)
files <- dir(folder)
#   ---- Determine if this is a singly or doubly sampled cell.
ranks <- getRankStatus()
double <- 0
if( ranks[ranks$Grid_ID == theNext,]$dblSamp == 1){
double <- 1
}
if( double == 1 ){
#   ---- Double, so make sure there is an 's' and 'reconciling' shapefile.
sInd <- substr(files,1,1) == 's' &
substr(files,nchar(files) - 3,nchar(files)) == ".shp" &
grepl("Towns",files,fixed=TRUE)
sShpC <- substr(files[sInd],1,nchar(files[sInd]) - 4)
#   ---- Double, so make sure there is an 's' and 'reconciling' shapefile.
rInd <- (substr(files,1,11) == 'reconciling' &
( substr(files,nchar(files) - 3,nchar(files)) == ".shp" |
substr(files,nchar(files) - 3,nchar(files)) == ".txt" ) )
rShpC <- substr(files[rInd],1,nchar(files[rInd]) - 4)
if( is.na(rShpC) | is.na(sShpC) | is.null(sShpC) | is.null(rShpC) | length(sShpC) == 0 | length(rShpC) == 0 ){
#   ---- Remove the lock, if it exists, and the user calling the function placed it there.
if(invisible(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt"))){
if(userID == read.table("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",stringsAsFactors=FALSE)[2,1]){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
}
}
stop("The folder tied to the doubly sampled Grid_ID provided lacks the requisite 's' and 'reconciling' shapefiles.  Investigate.")
}
}
#   ---- Find the primary shapefiles.
pShp <- sShp <- NA
pInd <- substr(files,1,1) == 'p' &
substr(files,nchar(files) - 3,nchar(files)) == ".shp" &
grepl("Towns",files,fixed=TRUE)
pShpC <- substr(files[pInd],1,nchar(files[pInd]) - 4)
if( is.na(pShpC) | is.null(pShpC) | length(pShpC) == 0 ){
#   ---- Remove the lock, if it exists, and the user calling the function placed it there.
if(invisible(file.exists("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt"))){
if(userID == read.table("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",stringsAsFactors=FALSE)[2,1]){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
}
}
stop("The folder tied to the doubly sampled Grid_ID provided lacks the requisite 'p' shapefile.  Investigate.\n")
}
#   ---- Need to see if we have shapefiles with no features. This happens often.
checkShp <- function(folder,shp){
if(is.null(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message)){
shp2 <- tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)
} else if(tryCatch(readOGR(folder,shp,verbose=FALSE), warning = function(w) w)$message == "no features found" ){
shp2 <- 'no features found'
}
}
#   ---- Read in shapefiles, allowing for no features found.
pShp <- checkShp(folder,pShpC)
if( double == 1){sShp <- checkShp(folder,sShpC)}
#   ---- Check and see if there are errors that should be remedied via
#   ---- the town tool in Arc.
readCheckCellValidity <- function(Shp){
out <- tryCatch(
{
checkCellValidity(Shp,userID)
},
warning = function(cond){
return(1)
}
)
return(out)
}
#   ---- Apply the checking function, collecting any evidence of a warning.
checkApply <- function(shp){
if(class(get(paste0(substr(shp,1,1),'Shp'))) == "SpatialPolygonsDataFrame"){
lapply(shp,readCheckCellValidity)
#   ---- The function call to readCheckCellValidity gets rid of the lock.  Put it back for the
#   ---- function checkInCell.
#   ---- Check for a lock on table tblCellStatus.csv
lock <- grep("tblCellStatusLOCK",dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database"),fixed=TRUE)
if(length(lock) > 0){
stop("The function is currently locked;  try again in a minute.")
} else {
#   ---- Lock the table tblCellStatus so that two users cannot update
#   ---- it at the same time.
lockdf <- data.frame(userID=userID)
write.table(lockdf,"//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",row.names=FALSE)
}
} else {
cat(paste0("The check of ",shp," found no towns to check.  Be sure this is correct. If so, continue.\n"))
}
}
pShpCCheck <- checkApply(pShpC)
if( double == 1){sShpCCheck <- checkApply(sShpC)}
#   ---- Update the tblCellStatus csv so that this cell is officially checked in.
#   ---- The real deal version.  Note that we convert these columns to POSIX, which make
#   ---- them look different than the others (dates are now separated with a '-' instead of
#   ---- a '/', but it doesn't matter as long as they all look the same in the end.)
assign$digiEndTime <- as.POSIXlt(assign$digiEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver")
assign$buffEndTime <- as.POSIXlt(assign$buffEndTime,format="%m/%d/%Y %H:%M",tz="America/Denver")
#   ---- First, update the cell that was digitized.
assign[assign$Grid_ID == theNext,]$openStatus <- 1
assign[assign$Grid_ID == theNext,]$digiStatus <- 0
assign[assign$Grid_ID == theNext,]$digiEndTime <- as.POSIXct(Sys.time(),format="%m/%d/%Y %H:%M",tz="America/Denver")
assign[assign$Grid_ID == theNext,]$doneStatus <- 1
#   ---- Next, update the cells that were locked via buffering.
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffStatus <- 0
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffUserID <- NA
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffPartner <- NA
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffEndTime <- as.POSIXct(Sys.time(),tz="America/Denver",format="%m/%d/%Y %H:%M")
assign[assign$buffLockGrid_ID == theNext & !is.na(assign$buffLockGrid_ID),]$buffLockGrid_ID <- NA
head(assign)
class(assign$digiStartTime)
class(assign$buffEndTime)
head(strftime(assign$buffEndTime,format="%m/%d/%Y %H:%M"))
#   ---- Put these date fields back to character, so Excel doesn't get confused.
assign$digiEndTime <- head(strftime(assign$digiEndTime,format="%m/%d/%Y %H:%M"))
assign$buffEndTime <- head(strftime(assign$buffEndTime,format="%m/%d/%Y %H:%M"))
assign$digiEndTime <- strftime(assign$digiEndTime,format="%m/%d/%Y %H:%M")
assign$buffEndTime <- strftime(assign$buffEndTime,format="%m/%d/%Y %H:%M")
head(assign)
vList <- dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus")
version <- max(substr(vList,nchar(vList) - 9,nchar(vList) - 4))
newVersion <- sprintf("%06d",(as.numeric(version) + 1))
write.csv(assign,paste0("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatus/tblCellStatusxxx",newVersion,".csv"),row.names=FALSE)
assign <- read.csv(paste0("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/",userID,"/tblCellStatusTMP.csv"),stringsAsFactors=FALSE)
head(assign)
assign <- read.csv(paste0("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/",userID,"/tblCellStatusTMP.csv"),stringsAsFactors=FALSE)
head(assign)
userID
#   ---- Check for a lock on table tblCellStatus.csv
lock <- grep("tblCellStatusLOCK",dir("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database"),fixed=TRUE)
if(length(lock) > 0){
stop("The function is currently locked;  try again in a minute.")
} else {
#   ---- Lock the table tblCellStatus so that two users cannot update
#   ---- it at the same time.
lockdf <- data.frame(userID=userID)
write.table(lockdf,"//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt",row.names=FALSE)
}
#   ---- Define useful projections.
projAEAc  <- '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0'
#   ---- Check to make sure user is legitimate.
tblNames <- checkUser(userID)
pFirstName <- as.character(droplevels(tblNames[tblNames$userID == userID,]$FirstName))
singleActive <- tblNames[tblNames$userID == userID,]$singleActive
doubleActive <- tblNames[tblNames$userID == userID,]$doubleActive
#   ---- Get folder structure.
tblFolders <- getFolderStatus()
#   ---- Get the current list of who has what.
assign <- getCellStatus()
assign$digiStartTime <- as.POSIXlt(strptime(assign$digiStartTime,format="%m/%d/%Y %H:%M"),tz="America/Denver")
assign$digiEndTime <- as.POSIXlt(strptime(assign$digiEndTime,format="%m/%d/%Y %H:%M"),tz="America/Denver")
assign$buffStartTime <- as.POSIXlt(strptime(assign$buffStartTime,format="%m/%d/%Y %H:%M"),tz="America/Denver")
assign$buffEndTime <- as.POSIXlt(strptime(assign$buffEndTime,format="%m/%d/%Y %H:%M"),tz="America/Denver")
anyOpen <- assign[assign$digiStatus == 1 & assign$digiUser == userID & assign$digiPartner == 998,]
if(nrow(anyOpen) > 0){
file.remove("//LAR-FILE-SRV/Data/BTPD_2016/Analysis/Database/tblCellStatusLOCK.txt")
stop("Records indicate you have checked out singly digitized cell ",anyOpen[1,]$Grid_ID,".  Finish and close it, and then try again.")
}
#   ---- Get the BAS rankings.
ranks <- getRankStatus()
#   ---- Make a master data frame.
master <- merge(assign,ranks,by=c("Grid_ID"),all.x=TRUE,all.y=TRUE)
master <- master[order(master$digiStatus,master$sampleID),]
#   ---- A safeguard to ensure we have all 11,101 records.
nTotal <- nrow(master)
if( !(nTotal == 11101) ){
warning("Creation of data frame master does not have the correct number of records.  Investigate")
stop
}
#   ---- Get the big grid so we can subset to the buffer below.
shpDir <- "//lar-file-srv/Data/BTPD_2016/Analysis/data/Shapefiles/BTPD_Grid_CO_Ranked"
shp <- "BTPD_Grid_CO_Ranked"
shpObj <- readOGR(shpDir,shp,verbose=FALSE)
#   ---- We now need to find a cell whose buffer is available.
open <- master$openStatus    # The cell still needs to be digitizing.
digi <- master$digiStatus    # The cell is locked for digitizing.
buff <- master$buffStatus    # The cell is locked for buffering.
done <- master$doneStatus    # The cell has been digitized and reconciled, if necessary.
doub <- master$dblSamp       # The cell is a doubly-sampled cell.
#   ---- Could have a few open cells, but they're locked for digitizing or buffering.
#   ---- If somebody is turned off for doubly-sampling, here is where we exclude
#   ---- those cells from them.
if( doubleActive == 0 ){
valid <- open & !digi & !buff & !done & !doub    # Want:    1  &  0  &  0  &  0  &  0
} else {
valid <- open & !digi & !buff & !done            # Want:    1  &  0  &  0  &  0
}
nValid <- length(valid[valid == TRUE])
